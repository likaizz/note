Oracle{
create tablespace  my_tablespace DATAFILE 'E:\Java\Oracle\oradata\my\my_tablespace_1.dnf' size 512m AUTOEXTEND ON NEXT 512m,'E:\Java\Oracle\oradata\my\my_tablespace_2.dnf' size 512m AUTOEXTEND ON NEXT 512m,'F:\Java\Oracle\oradata\my\my_tablespace_1.dnf' size 512m AUTOEXTEND ON NEXT 512m,'F:\Java\Oracle\oradata\my\my_tablespace_2.dnf' size 512m AUTOEXTEND ON NEXT 512m
CREATE TABLE person (ID varchar2(64), name varchar2(50),person_id number(16),age number(3),create_time date)
		PARTITION BY hash (ID) 
(
  partition p1 tablespace lk_tablespace,
  partition p2 tablespace my_tablespace,
);

PARTITION BY RANGE (CUSTOMER_ID)  
(  
    PARTITION CUS_PART1 VALUES LESS THAN (100000) TABLESPACE CUS_TS01,  
    PARTITION CUS_PART2 VALUES LESS THAN (200000) TABLESPACE CUS_TS02  
);  
PARTITION BY RANGE (ORDER_DATE) 
(PARTITION P1 VALUES LESS THAN (TO_DATE('2004-7-1', 'YYYY-MM-DD')), 
    PARTITION P2 VALUES LESS THAN (TO_DATE('2005-1-1', 'YYYY-MM-DD')), 
    PARTITION P3 VALUES LESS THAN (TO_DATE('2005-7-1', 'YYYY-MM-DD')), 
    PARTITION P4 VALUES LESS THAN (MAXVALUE)
	);


create or replace procedure p_create_person (num in number) as 
begin 
 for i in 1..num  loop
 insert into person values(sys_guid(),'name'||i,i, dbms_random.value(0,150),sysdate);
 end loop;
 end;
 
 
 select * from person where rownum<=1 FOR UPDATE nowait; --无等待,如遇锁直接异常
 There was an unexpected error (type=Internal Server Error, status=500).
java.lang.ClassNotFoundException org/springframework/core/JdkVersion  --spring遇上的死锁异常
 
 
}





js{
var str='function(){emit(this.end,1);}'
eval("("+str+")");//解析字符串得到对象



}	

mongoDB{
var arr=db.getCollection('multiEnd').find({value:{$gte:2}},{_id:1})
// typeof arr  //object
arr.constructor  //DBQuery
db.BaseRelation.find({end:{$nin:arr.toArray()}})

var obj=db.BaseRelation.aggregate([{$group:{_id:"$end",count:{$sum:1}}},{$match:{count:{$gte:2}}}],{allowDiskUse:true})
obj.constructor //Object
obj.itcount()  //分组的数量

//存储过程
db.system.js.update({_id:'more2moreResult'},{_id:'more2moreResult',value:function(){
    var aggregate=db.BaseRelation.aggregate([{$group:{_id:"$end",count:{$sum:1}}},{$match:{count:{$gte:2}}}],{allowDiskUse:true});
    var excludes=aggregate.toArray();
    var resultArr=[];
    for(var i=0;i<excludes.length;i++){
        resultArr.push(excludes[i]._id);
        };
        return resultArr;
    }});
    
    db.eval('more2moreResult()')


//分组聚合有内存空间限制和输出结果集大小限制
//分组聚合对操作的先后顺序有严格要求

db.BaseRelation.aggregate([{$group:{_id:"$end",count:{$sum:1}}},{$match:{count:{$gte:2}}}],{allowDiskUse:true}) //allowDiskUse表示可以使用硬盘空间

db.BaseRelation.aggregate([{$group:{_id:'$end',count:{$sum:1},ids:{$push:'$_id'}}},{$unwind:"$ids"},{$project:{_id:"$ids",count:"$count"}},{$sort:{_id:1}},{$out:"BaseRelation_group"}],{allowDiskUse:true})//{$project:{count:1,id:"$ids"}} {$unwind:"$ids"}, {$unwind:"$_ids"},db.BaseRelation.aggregate([{$group:{_id:'$end',count:{$sum:1},ids:{$push:'$_id'}}},{$group:{_id:'$count',ids:{$push:"$ids"}}},{$out:"BaseRelation_group"}],{allowDiskUse:true})

//关联查询并且合并结果 1对一
db.BaseRelation_start.aggregate([
{$lookup:{from: "BaseRelation_end",
         localField: "_id",
           foreignField: "_id",
          as: "inventory_docs"}},
          
          {
      $replaceRoot: { newRoot: { $mergeObjects: [ { $arrayElemAt: [ "$inventory_docs", 0 ] }, "$$ROOT" ] } }
   },
   { $project: { inventory_docs: 0 } },
         
          {$out:"group_result"}
],
{allowDiskUse:true})


}

neo4j{
<dependency>
    <groupId>org.neo4j.procedure</groupId>
    <artifactId>apoc</artifactId>
    <version>3.2.0.1</version>
</dependency>

}
	
	
	
{String str=String.format("%06d",i);//6位数不足补0
    @Test
    public void createRela() {
        List list = new ArrayList(100000);
        for (int i = 1; i <= 400000; i++) {
            int rnum = 8;
            HashSet<Integer> set = new HashSet<Integer>(10);
            for (int j = 0; j < rnum; j++) {
                Relation r = new Relation();
                r.setStart(String.format("%06d", i));
                int from = 0, to = 0;
                if (i % 2 == 1) {
                    int n = (i + 1) / 2;
                    to = n * 10 + 1;
                } else {
                    int n = (i / 2);
                    to = n * 10 + 6;
                }
                from = to - 10;
                int e = 0;
                do {
                    e = RandomUtils.nextInt(from, to);
                } while (!set.add(e));
                String end = String.format("%07d", e);
                r.setEnd(end);
                list.add(r);
                if (list.size() == 100000) {
//                        System.out.println(list);
                    template.insert(list, "ralationx");
                    list.clear();
                }
            }
        }
    }


}
	
	
	
    

   


从windows本地dos命令向linux上传文件:  pscp G:\tts9\tts9.7z root@192.168.8.100:/var/develop/

数据库{
mysql{
字符串函数、数学函数、日期时间函数、搜索函数、加密函数、信息函数。

获取当前数据库时间的毫秒数   select unix_timestamp()*1000;  必须乘以1000

select @@tx_ioslation;--查看当前数据库的隔离等级
set session transaction isoalation level read commit;
1.串行化(序列化) 最高级别的隔离,效率最低,最安全(每个线程(事务)之间按顺序执行,一个事务结束后另外一个事物才能执行)
2.可以重复读取//MySql默认
3.读取提交后的数据(修改状态的数据读不到)//Oracle默认(并发和安全的平衡选择) 可以同时开启读和写的事务,但只能读取写入操作中提交的数据,可能在一次读的事务中,
4.可以读取修改中(未提交的数据)的数据(脏读)

1.脏读 (read commit)//针对update操作
2.不可复读(repeatable Read)//(update操作)
3.幻读(删除插入操作)//针对delete/insert操作


grant all on *.* to 'user10'@'%';最高权限

grant select on test.* to "lk"@localhost;
revoke select on test.* from "lk"@localhost;

revoke 权限1, 权限2..... on 数据库.表 from '用户名'@'IP地址';
grant  权限1, 权限2..... on 数据库.表 to   '用户名'@'IP地址';

create user 王舞 @'localhost'  identified by 'password';--创建本地用户
create user maliu@'IntAddress' identified by 'password';--创建指定ip地址的用户
create user maliu@'%' identified by 'password';--创建本地或远程用户

use mysql;
update user  set password=password("xxx") where user="likai";
flush privileges;

//登录数据库
mysql -u root -p database_name;
use database_name;



set autocommit=0;--设置自动提交事务为false;

begin start transaction

mysql没有非空函数,使用isnull(字段,null时取出的值);
nvl()
nvl2()



alter table emp add column_name after column_name_exists;  //把新的字段添加到已存在的字段后面



select case cn_note_status_id when "1" then "ss" when "0" then "00" else "" end from cn_note;
							if(boolean 表达式	,true , false)
select if(cn_note_status_id="1","ok","error") from cn_note where cn_note_id="fed920a0-573c-46c8-ae4e-368397846efd";

按小时分组select date_format(hiredate,"%Y%M%D%H") hour,count(*) num from emp group by hour;


//增加索引
create index idx_ename on table_name(column);
alter table table_name add index idx_name (column); 

索引是B tree ,模糊查询步骤 B tree
index full scan 可以走模糊查询

//建立临时表
create temporary table tem_table_name ();


case语句
case column when  xxx then xxx when xxx then xx  else  xxx end

}

oracle{
	like "%xxxx" 列索引失效
	index full scan
decode(column,case a,do a,case b,do b,全部不匹配默认执行);
case column when  xxx then xxx when xxx then xx  else  xxx end


笛卡尔坐标系:
表a的记录数*表b的记录数

exec dbms_stats.gather_table_stats('SYS','T1');

}

}

jdbc{
driverClass
url
user
password

数据库连接池: DataSource(配置连接池)

dbcp : BasicDataSource
c3p0:  ComboPooledDataSource
spring-jdbc：连接池　 DriverManagerDataSouce
iBatis : 	PooledDataSource
}



//常用程序的端口号
oracle: 1521
mysql: 3306
tomcat: 8080  (80)



int pos;
int size;
String next;
Enumeration<T>enumeration
while(enumeration.hasMoreElements()){
T ele = enumeration.nextElement();
}



过滤器(Filter)是基于回调,拦截器(Interceptor)是基于反射

位运算符: ^ & | ~ << >> >>>


java对象的比较排序必须要实现Comparable接口,否则会报异常:
java.lang.ClassCastException: demo04.Emp cannot be cast to java.lang.Comparable
原理:比较对象时需要用到Comparable接口的实现方法(Comparable内部比较器)

Comparator接口(外部比较器,临时创建的比较器)
比较两个对象的大小

集合框架里面用的比较多


javascript

数组排序:
js数组存放的元素可以是任意对象
var array=[1,21,11,56];
array.sort();
从数字的最高位数字开始比较,不是比较数值
需要传入比较函数
array.sort(function(a,b){return a-b;});

[null, 1, true, 2, "3", 9, 21, NaN, undefined]
null<false=0<true=1<NaN<undefined
null-NaN=NaN;

//任何数字与undefined计算结果都为NaN;

null+undefined
NaN
null+false
0
undefined+undefined
NaN

//js检查表单提交的数据
<script>
function validateForm(){
var x=document.forms["myForm"]["fname"].value;
if (x==null || x==""){
  alert("姓必须填写");
  return false;
  }
}
</script>

background-attachment 有三个值，scroll是默认值，背景图像会随着页面其余部分的滚动而移动。 fixed当页面的其余部分滚动时，背景图像不会移动。 inherit规定应该从父元素继承 background-attachment 属性的设置。 background-origin 属性规定 background-position 属性相对于什么位置来定位。 background-clip 属性规定背景的绘制区域。
字符串与数字不能进行判断,编译错误;

哈希查找的时间复杂度为O(1);
java垃圾回收机制采用分代收集,其中堆大概分为两代
 虚拟机中的共划分为三个代：年轻代（Young Generation）、年老点（Old Generation）和持久代（Permanent Generation）。

2位的十六进制数就是一个字节：0x12&0x0f结果为0x12的的后四位
 
 switch 参数类型:byte,short,int,String,char,enum,Byte,Short,Integer,Character共10种
 
 
1.数据类型
	1.1基本数据类型
	1.2引用数据类型
	
	int 与Integer对象==比较,Integer对象自动拆箱用int值比较
	
	Integer对象与Integer对象==比较,比较的是引用
	Integer对象维护了一个byte常量池,-128到127范围的值
	通过Integer i=127;Integer i2=127;这样的对象==结果为true
	
	超出范围,则为false
	其他所有new出来的地址值一般都不同
	
	
	Long 的常量池范围为Integer.MIN_VALUE~Integer.MAX_VALUE;
	
	int 转 字符串
	int x=1;
	String str=String.valueOf(x);
	String str=Integer.toString(x);
	String str=x+"";
	
	字符串转成数字:可能失败,抛出异常throw new NumberFormatException();
	String str="12";
	int x=Integer.parseInt(str);
	int x=Integer Integer.valueOf(str);//这里做了自动拆箱
	
	日期转成格式化字符串
	Date d=new Date();
	SimpleDateFormat sdf=new SimpleDateFormat();
	String str=sdf.parse(str); throw new ParseException() extends Exception;
	Date d=sdf.format(d);//格式化日期

2.数据状态
	2.1常量
		字面值常量(整数,小数,布尔值true,false,字符,字符串,)
		自定义常量(final修饰的变量)
	2.2变量

	null状态,undefined

3.关键字,标识符,命名法,修饰符

4.线程
Exception: InterruptedException
		   ConcurrentModificationException
		   
		 
		   
实现多线程的方式:
1. 继承Thread类
2. 实现Runable接口
3. 实现Callable接口通过FutureTask包装器来创建Thread线程
4. 使用ExecutorService、Callable、Future实现有返回结果的多线程。


通过 Callable 和 FutureTask 创建线程
1. 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值(返回值为泛型)。
2. 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。
3. 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。
4. 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。



	线程通信:不同种类的线程对于同一个资源的操作
	多线程:
	同步,异步
	死锁
	线程池:


5.异常

6.IO

7.sql
{
	一.添加约束
在字段定义完毕后直接添加 constraint student_id_pk primary key
在所有字段定义完毕后添加constraint student_sex_ck check (sex in('f','m'))

为表格(service)的字段accountid添加外键约束(account 的字段accountID)方法:
 A.直接在定义字段后添加 REFERENCES account(accountid)
 B.在表所有字段定义结束后添加 FOREIGN KEY(accountid) REFERENCES account(accountid)
 C.在表创建后执行如下命令：ALTER TABLE service ADD FOREIGN KEY(accountid) REFERENCES account(accountid)

PreparedStatement 设置字段属性的时候自动进行数据类型匹配检查
Statement执行sql语句的时候是直接传入一个字符串的，不存在对传入数据类型的检查
PreparedStatement void setObject(int index,Object o);
PreparedStatement void setInt(int index,int i);


create trigger tr_stu_sex before insert on stu for each row begin if new.sex not in ('M','F') then insert into stu(id) values(1);

select name from stu ,(select a.sid  sid from (select score,sid from score where cid=1)a,(select score ,sid from score where cid=2)b where a.sid=b.sid and a.score>b.score) r where stu.sid=r.sid

连接池:
dbcp: new BasicDataSource();
c3p0: new ComboPoolDataSource();

Statement
PreparedStatement
CallableStatement(继承于PreparedStatement)
String callSql="{call sp_name(?,?,?)}";

Types存了数据库字段数据类型与java数据类型的对应

数据库SQL:  ojdbc
连接池需要导入两个外包(dbcp)


Oracle:
driver=oracle.jdbc.driver.OracleDriver  
url=jdbc:oracle:thin:@IntAddress:port:sid  
	jdbc:oracle:thin:@(DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=zishan
	 (DESCRIPTION =(ADDRESS = (PROTOCOL = TCP)(HOST = localhost)(PORT = 1521))(CONNECT_DATA =(SERVER = DEDICATED)(SERVICE_NAME = my)))
	
create tablespace  lk_tablespace DATAFILE 'E:\Java\Oracle\oradata\my\lk_tablespace_1.dnf' size 1024m AUTOEXTEND ON NEXT 512m,'E:\Java\Oracle\oradata\my\lk_tablespace_2.dnf' size 1024m AUTOEXTEND ON NEXT 512m,'F:\Java\Oracle\oradata\my\lk_tablespace_1.dnf' size 1024m AUTOEXTEND ON NEXT 512m,'F:\Java\Oracle\oradata\my\lk_tablespace_2.dnf' size 1024m AUTOEXTEND ON NEXT 512m
	 conn /as sysdba;
//两种连接模式：thin模式(不需要oracle客户端)和oci模式(需要oracle客户端)
user=
pwd=
日期的默认格式:  
1:  "27 11月 1992"  | "27-11月-1992"     (中文环境下)
2:	"27 Feb 1992"   | "27-Feb-1992 "     (英文环境下)


MySql
driver=com.mysql.jdbc.Driver
url=jdbc:mysql://IntAddress:port/sid
user=
pwd=

日期的默认格式:  
1: "19921127"     (不能空格)
2:"1992-11-27 "       
MySql没有序列(Sequence),利用  to_increment  自动生成主键 (必须与主键配合使用,且只能增不能减,每次只能自增1) 
alter table emp modify  empno int auto_increment primary key
insert into emp (ename,job,sal)values("张三","工人",4000)     --不用写出empno号
insert into emp values(null,'haha','haha',1234,"1992-11-27",234,null,20)   --全部数据写入的话empno需要写入null让系统自动生成

 oracle默认null为最大值,mySql默认null为最小值
 
 mysql:
 select * from emp order  by mgr desc limit m;  --扫描表内符合条件的(<=m)条记录并取出（有可能符合条件的记录不足m条）
 select * from emp order  by mgr desc limit m,n;--扫描表内(m+n)条符合条件的记录，并取出最后n条记录
 
 
}
8.jdbc


9.反射
reflect

Class 类
Constructor
Method
Field

Annotation 



动态代理:
jdk中动态代理的实现依赖于一个实体工具类Proxy以及一个InvocationHandler接口



10.Servlet
{
	
	jsp：
	SimpleTagSupport
	
	HttpServlet.service();  //无论哪种请求方式,都是经过该方法分发到具体的doGet()方法
	
Get请求头:  request.getHeader()
host : localhost:8080
connection : keep-alive
user-agent : Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.108 Safari/537.36
accept : */*
referer : http://localhost:8080/mytest/test.do
accept-encoding : gzip, deflate, br
accept-language : zh-CN,zh;q=0.9
	
	
	
post请求头:(content,content-length,content-type)
content-type : application/x-www-form-urlencoded
content-type : text/plain;charset=UTF-8 (post请求默认的)


host : localhost:8080
connection : keep-alive
content-length : 0
origin : http://localhost:8080
user-agent : Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.108 Safari/537.36
content-type : text/plain;charset=UTF-8
accept : */*
referer : http://localhost:8080/mytest/test.do
accept-encoding : gzip, deflate, br
accept-language : zh-CN,zh;q=0.9

$.ajax({
          type: type,
          timeout: 10000, // 超时时间 10 秒
          headers: {
              'Access-Token':$.cookie('access_token')
          },
          url: url,
          data: data,
          success: function(data) {
          },
          error: function(err) {
          },
          complete: function(XMLHttpRequest, status) { //请求完成后最终执行参数　
          }
      });	

js获取cookie
document.cookie;//返回一个cookie字符串
var cookieArray=document.cookie.split(";");//把cookie字符串分割成cookie字符串数组	  
	
cookie大小有限制(4k),数量有限制,只能存字符串,可以被用户禁止
Servlet默认设置cookie的有效时长为-1,保存在内存中
禁用session,使用url重写来提交sessionid http://localhost:8080/test/some;jsessionid=4E113CB3(在url后面加上分号)
生成链接地址和表单提交时，使用如下代码：
<a href=”<%=response.encodeURL(String url)>”>链接地址</a>
如果是重定向，使用如下代码代替response.sendRedirect()
response.encodeRedirectURL(String url);


get方式提交数据,是可见的,有大小限制(2k),使用路径直接传递参数
浏览器第一次访问服务器,服务器为期创建一个session对象,里面储存了sessionID,响应时将这个
sessionid保存在response对象里面.浏览器收到的响应头数据中set-cookie里面存的就是sessionid的信息

立刻删除Session对象 void Session.invalidate();
session的有效时间在Server(Tomcat)的web.xml文件中配置(默认缺省时间为30分钟)
 <session-config>
        <session-timeout>30</session-timeout>
  </session-config>

服务器的时间和时区设置可能影响Cookie，IE而言，Cookie的有效时间段是理解为客户端的时间与服务器端时间的间隔，对于FireFox而言，Cookie的有效时间完全由服务器端的时间决定

//jackson-API解析(对象转换为json字符串,将json字符串转换成对象)
response.setContentType(String type); //  text/html | image/png  application/json
ObjectMapper mapper=new ObjectMapper();
String json=mapper.writerValueAsString(Object);


//gjson(谷歌出品的json工具)
Gson tool=new Gson();
String json=tool.toJson(Object o);


//fastjson(阿里巴巴出品的解析json工具)

摘要加密
//不适合数据加密传输
摘要加密的特点：不适用密钥，使用摘要加密算法对明文进行加密之后会得到密文，无法反推出明文。唯一性：不同的明文有不同的密文。不可逆性：即使知道了摘要加密算法，也无法反推出明文。
1.4.2. 如何实现摘要加密
public class MD5Util{
    private static void test1() throws NoSuchAlgorithmException{
        String str = "I love you";
        MessageDigest md = MessageDigest.getInstance("md5");
        //依据指定的加密算法进行加密
        byte[] buf = md.digest(str.getBytes());
        //因为字节数组不方便使用，所以，将其转换成一个字符串
        //BASE64Encoder的encode方法可以将任意的一个字节数组转换成一个字符串
        BASE64Encoder  base = new BASE64Encoder();
        String str2 = base.encode(buf);
        System.out.println(str2);
}
    public static String encrypt(String  origStr){
        MessageDigest md = MessageDigest.getInstance("md5");
        byte[] buf = md.digest(str.getBytes());
        BASE64Encoder  base = new BASE64Encoder();
        String str = base.encode(buf);
        return str;
    }
}
}

11.html
{
<form>标记中有如下常用属性。
Action:用于确定表单的提交目的地址
Method:用于指定表单数据的提交方式，常用有get/post/(put,delete)
Enctype:用于指定表单数据的编码类型。



escape(str);//对字符串进行编码


}



子类创建对象默认会访问父类的无参构造方法,但并没有创建父类的对象（创建对象需要用到关键字 new ）
new Foo()  和Foo()的区别,new表示创建了对象,在内存开辟了空间,Foo()仅仅表示调用构造方法,把成员变量初始化后赋值给子类对象

{一个类中若没有声明其构造方法,则编译器默认会自动为其添加一个public修饰的无参构造方法,很多框架可以调用该无参构造方法创建对象}
spring框架创建对象时会通过反射机制暴力调用构造器或者静态工厂方法(无视权限)


多态,解耦(传入最大的接口,方便后续代码的维护,传入的实体对象实现类有可能以后需要修改)






class文件的装载:
1.加载.class文件进内存
2.连接 检查内部结构,为静态成员分配空间,设置默认初始值,符号引用替换为直接引用
3.初始化 



类加载进方法区:
首先执行静态变量(先默认初始化,然后进行自定义的显示初始化(如果有的话))和静态代码块(平级关系,按书写的先后顺序执行) 
静态变量的默认初始化和静态代码块的执行不论他们在文件中的顺序
static int x(=0;);static {} 
然后再执行构造代码块和成员变量
最后在执行构造方法
1.static {静态变量,静态代码块(在class文件进方法区后执行且只执行一次)}
2.{成员变量,(构造)代码块(每次创建对象时调用)}
3.(public) Class_Name(){构造方法(每次创建对象之后调用)}
 
new Zi(); //创建子类对象,首先加载父类,访问其构造方法super();
Foo.static代码块
Zi静态代码块
Foo构造代码块
Foo构造方法
Zi构造代码块
Zi()构造方法

首先加载父类和子类的全部static代码块

抽象类实现了某个接口,该接口的方法可以在抽象类中不写,默认存在该抽象方法
 

(二进制数)  				正数       负数
计算机显示:		原码				
过渡值:			反码		不变	原码的1变0,0变1,最高符号位的1不变
计算机识别值:		补码		不变	反码数值加1,最高符号位的1不变
进行逻辑运算(&,|)时,0相当于false,1相当于true
位异运算符(^),一个数与另一个数连续位异两次,其值不变  
eg:  a=a^b;
	 b=a^b;  //a^b^b=a;
	 a=a^b;	//a^b^a=b;
<<,>>,>>>

 
查看本机IP地址:
linux    ifconfig
windows  ipconfig     
查看端口:netstat -ano  (中间'-'前面有空格)

html
特殊实体符号:  &emsp(大空格)    &nbsp  &lt &gt  
<pre>
pre 元素可定义预格式化的文本。被包围在 pre 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。
标签的一个常见应用就是用来表示计算机的源代码。
</pre>
<hr/>定义水平线



Servlet
http://IntAddress:port/app-name/url-pattern
302:重定向      
 void javax.servlet.http.HttpServletResponse.sendRedirect(String path) throws IOException
错误:
404:(服务器找不到地址) 
项目没有部署 自定义Servlet对象书写不规范或者没有在web.xml配置文件书写或者书写不正确   网络路径写错


HttpServlet.getServletContext()==GenericServlet.getServletContext()
==GenericServlet.getServletConfig().getServletContext()
ServletContext接口的数据是所有网站自定义Servlet对象共享的
  getServletContext()     getAttribute(String para-name)    setAttribute(String para-name,object para-value)
  
  获取配置文件的参数: Object.getInitParameter(String name);
  
其中,setAttribute(String para-name,object para-value)方法中如果传入数字并且自增,需要用setAttribute("count",++count),
如果用setAttribute("count",count++),这不发生自增(值不变)  每次获取到的值为0  (只对count有效)


ServletContext 定义属性的方法:
1.在servlet类当中获取     getServletContext().setAttribute(String para-name,object para-value);
2.在web.xml配置文件中直接书写
<context-para>
<param-name></param-name>
<param-value></param-value>
</context-para>

Servlet类加载的优先顺序在
<servlet>
<load-on-startup>1</load-on-startup>
</servlet>
数值必须大于等于1,如有相同优先级的,则按xml先后顺序加载,如果是其他数字或者字符串,则不能识别,只能在第一次访问时加载


XML解析方式
1. SAX解析方式
SAX（simple API for XML）是一种XML解析的替代方法。相比于DOM，SAX是一种速度更快，更有效的方法。
它逐行扫描文档，一边扫描一边解析。而且相比于DOM，SAX可以在解析文档的任意时刻停止解析。 
优点： 解析可以立即开始，速度快，没有内存压力
缺点： 不能对节点做修改  ????
2. DOM解析方式
DOM：(Document Object Model, 即文档对象模型) 是 W3C 组织推荐的处理 XML 的一种方式。DOM解析器
在解析XML文档时，会把文档中的所有元素，按照其出现的层次关系，解析成一个个Node对象(节点)。
优点:把xml文件在内存中构造树形结构，可以遍历和修改节点
缺点： 如果文件比较大，内存有压力，解析的时间会比较长


jQuery

$(":button:eq(0)").attr("value","+")
obj.remove();  obj.remove(SELECTOR);
obj.empty();
e.stopPropagation();
e.target;//DOM对象
e.pageX
e.pageY

$("#id_value").subling

回调函数
animate




Servelet  SpringMVC  Struts

静态网页:维基百科,百度百科,小说,新闻,开发手册网页
服务器保存一份HTML文件,响应请求时直接发送该文件

********
动态网页:显示内容因人而异
ObjcetInputStream  ObjectOutputStream 
transient  
服务器保存一个对象,由该对象动态拼成一个网页,发送给浏览器
在java中该对象是 Servelet

Servelet: 满足(SUN|Oracle)规范的对象是组件
储存在服务器上,可以动态的拼接资源(HTML,IMG).  处理HTTP协议

Servelet: SUN推出的用来在服务器端处理HTTP协议的组件(动态网页)


服务器:  本质是一个软件:可以运行Java(WEB)项目的软件运行环境(JAVAEE)
-Tomcat(Apache)
-JBoss
-WebLogic
-WebSphere

Tomcat:本质是软件,可以直接运行使用
1.单独使用(很麻烦):在软件上线的时候在独立运行
2.通过Eclipse管理***

Apache 是 PHP 程序运行的服务器，IIS 是.net 程序运行的服务器

Servlet:  
Tomcat: 加权限:  chmod +x *sh
sh shutdown.sh


URIEncoding="UTF-8"
Cookie URLEncdoer.encode("张三","utf-8");  URLDecoder.decode("张三","utf-8");
1.创建一个Maven项目, war类型打包封装
2.generat deployment(部署web.xml文件)
3.properties target apache(引入javaee的jar外包)
4.new class extends HttpServlet
5.@override
protected void Service(ServletRequest req,ServletResponse rep)throws ServletException,IOException{}

Tomcat服务器本身并不能调用私有构造方法创建对象
	
void Servlet.init(){}  方法,用来接收Tomcat容器传递过来的ServletConfig对象
里面储存了初始化信息(init-param标签内param-name value值)
http协议,还有别的协议比如ajp
Servlet接口:负责服务器与Java代码通信的规则
GenericServlet类:一般的Servlet类
HttpServlet类:专门处理http协议的servlet类
service方法:负责管理请求方式并分别处理的(service是请求的中转站(转交业务给doPost方法和doGet),当然本身也可以直接处理业务)
String method=req.getMethod();
		if(method.equals("Get")){
			doGet(req,rep);
		}
		else{
			doPost(req,rep);
		}
全局属性:项目内全部Servlet对象公共属性ServletContext 被封装进request对象自动传入service(request,response)方法内	
<context-param>
  <param-name></param-name>
  <param-value></param-value>
 </context-param>

配置Servlet对象
<servlet>
  <servlet-name>html</servlet-name>
  <servlet-class>web.HTMLService</servlet-class>
  Servlet类私有属性:ServletConfig  servlet对象初始化后调用Servlet.init(ServletConfig config){}方法传入
  <init-param>
	<param-name></param-name>
	<param-value></param-value>
  </init-param>
  <load-on-startup></load-on-startup>
</servlet>
<servlet-mapping>
  <servlet-name>html</servlet-name>
  <url-pattern>/html</url-pattern>
</servlet-mapping>
异常处理页面
<error-page>
	<exception-type></exception-type>  java异常类型   ||  <error-code>404</error-code>  //网页错误代码
  	
  	<!-- 转发的路径前缀一定是在该项目之内的 (错误页面必须写绝对路径,并且省略项目名(tomcat自动加的项目名))-->
  <location>/WEB-INF/error.jsp</location>
</error-page>
request的getReader()方法和getInputStream()方法
直接采用req.getReader()方法和 req.getInputStream()方法得到的数据不能正常显示(编码表没问题)
1>不显示数据(只能读取post方法提交的数据),而且读取完毕之后就没有数据了,不能复读
JSTL
<c:if test="判断条件">执行语句</c:if>
<c:choose >
<c:when test="判断条件">执行语句</c:when>
<c:when test="判断条件">执行语句</c:when>
<c:when test="判断条件">执行语句</c:when>
<c:
</c:choose>
<c:otherwise >执行语句</c:otherwise>

WEB-INF文件夹下的资源不能被浏览器直接通过路径访问到,起到对重要数据的保护作用
ServletConfig接口的是实现类对象在自定义的Servlet类创建唯一对象的时候由Tomcat自动创建,并在Servlet
调用init(ServletConfig condfig){}时自动传入并被Servlet类对象保存,然后这个
form表单的提交方式:
1.<input type="submit" />
2.超链接js绑定提交事件<a href="javascript:document.form[0].submit();">超链接名字</a>
	如果表单提交需要先通过函数验证数据,则需要改为onsubmit();
server.xml
URIEncoding='utf-8'



地址错误（拼写不正确，字母大小写错误）。
web.xml文件中的<servlet-name>不一致。
工程没有部署。
Web应用程序部署结构没有遵守Servlet规范。
service方法名称写错。
service方法参数类型与标准不一致。
service方法异常、返回值类型与标准不一致。
Servlet类没有继承HttpServlet或实现Servlet接口
web.xml文件中的<servlet-class>写错
service方法中的代码运行时抛出异常


Cookie的有效路径指的是产生该Cookie对象的网络路径及全部该路径以下的子路径(默认情况下)
Cookie的有效路径可以通过setPath(String path)重新定义

(
Integer i=1;
int i1=1;
System.out.println(i==i1);  //编译不报错结果为true
)

(
    int a=9;
		int b=11;
		boolean flag=a++>b--&&b++>a--; 
		//false  逻辑短路,后面不执行
		    System.out.println(flag+",a="+a+",b="+b);
		    //false  a=10,b=10   先进行判断,在自增自减
)

(
long l = 999999;  //编译不报错,数值在int范围内,自动转换为long

)

 //线程安全的类:Vector,Hashtable,BlockingQueue

truncate table t_name  --删除表格的全部数据不删表格,不可回退


Servlet{
请求方式:请求方式不同,服务器处理请求时采用的缓存也不同,提高响应速度
在HttpServlet中,service方法默认会根据请求方式不同而调用不同的doXXX方法
GET
POST
HEAD
PUT
DELETE
OPTION
TRACE

JSP9大内置对象
1.page
2.request
3.session (HttpSession)
4.application (ServeltContext)
5.config
6.pageContext(存取其他的内置对象,本身不能存储数据)本身是抽象类
7.response
8.out 
9.exception (ServletException,IOException)

Servelet(Jsp)中可以保存数据的三个不同的作用域(必须要有setAttribute(String,Object)):
1.request
2.session
3.context


cookie的值只能是ASCII字符，中文需要转换成ASCII码形式，使用URLEncoder.encode()方法和URLDecoder.decode()方法实现
cookie和session是为了解决多个request或者多个servlet类之间传递信息的问题:http协议是一个无状态协议,即服务器默认不会记住浏览器.
cookie和session是用来进行状态管理的
什么是状态? 状态就是浏览器访问服务器的证据(数据)
//浏览器首次访问服务器时,服务器(Tomcat)会自动给访问的浏览器创建一个session对象,并将session对象的SessioinID自动添加到response对象上发送给浏览器,此时会被监听器监听
servlet可以通过
request.getSession()方法来获取session对象的数据(JSESSIONID)
	javax.servlet.http.HttpSession session=req.getSession();
		//session是jsp9个内置对象之一,可以存储任意类型的数据(Object,需要转型)
		session.setAttribute("user", user);
		
		//服务器做出响应时,会自动创建Cookie对象,传入sessionID,设置路径为全局路径,并传给response对象一起发送给浏览器
	/*	Cookie c=new Cookie("JSESSIONID",session.getId());
		  c.setPath("/jsp5");
		  rep.addCookie(c);*/

session缺省时间设置:
1.web.xml配置文件  
<session-config>
	<!-- 这里的数字代表的是分钟 默认设置是30分钟-->
	<session-timeout>1</session-timeout>
</session-config>
2.servlet类当中单独设置
void Session.setMaxInactiveInterval(int seconds)	
URL重写:浏览器禁用cookie,服务器通过URL重写发送SESSIONID


监听器:
监听session,request,context对象的创建和销毁
监听session,request,context对象属性的更改(创建,移除,设置)


第一次请求net不会有记录?


如何生成验证码:
<img src='/createImg.do' title='点击更换' alt='验证码' onclick='this.setAttribute('src','createImg.do?num='+Math.random())'>
'createImg.do?num='+Math.random()这里是生成不同的请求
rep.setContentType("image/png");
		OutputStream os=rep.getOutputStream();
		ImageIO.write(image, "png", os);

公共业务:很多请求都需要进行处理的业务(登入检查,日志)
Servelet:处理请求
Filter:处理公共业务
一般为了降低耦合度
多个过滤器联用,按照web.xml配置文件中<filter-mapping>出现的先后顺序依次过滤
		
}

WEBbasic{
DOM对象:针对(html结构的)CRUD操作
(Document(8),Node(所有的对象都可以都是Node对象(包括元素标签,元素属性,元素文本,)),ElementNode(1),AttributeNode(2),TextNode(3),CommentNode(9),NodeList)
1.C  document.createElement();
		
2.R  document.getElementById("");
	 document.getElementsByTagName("");//通过标签名获取元素
	 document.getElementsByName("");//通过name属性获取元素        
	 document.getElementsByClassName("");//通过class属性获取元素  $('.className')
3.U 

4.D  
$('selector').remove();

创建函数的三种方法:
1:var f=new Function("a","b","return a-b;");
2:function f(a,b){return a-b;}  定义一个名字为f的方法
var f=function(a,b){return a-b;}  匿名函数
3.匿名函数  new function("a","b"){return a-b;}  不能用变量接收

创建一个Option对象var o=new Option("aa", 18);  //第一个变量表示下拉选的选项文本值为"a",value属性为18
向id="select"的元素上增加子元素option方法:
document.getElementById("select").add(o);
document.getElementById("select").appendChild(o);

html 页面上有一个 id 值为 s1 的 <select> 元素，现需要使用 JavaScript 代码清空其所有选项，
下列选项中，错误的是（B）。(options是元素的特殊属性,不可以被直接设为null状态.该属性是一个数组，可以通过设置数组的长度为0来清除数组中的元素，但是，不能试图去掉该属性。)
 A.document.getElementById("s1").options.length = 0;
 B.document.getElementById("s1").options = null;
 C.while (document.getElementById("s1").options.length > 0) {
		document.getElementById("s1").remove(0);
    }
 D.var selObj = document.getElementById("s1");
   while (selObj.childNodes.length > 0) {
             selObj.removeChild(selObj.lastChild);
   }

location.href=""  //保留浏览历史
location.replace=""  //不会保留浏览历史
history.go(x)  //只能前往已访问的地址  x可以为数字(正整数表示前进,负整数表示后退,url字符串直接前往该地址(如果访问过))

WEB{
html网页中如果多个元素设置同value值的id属性,css中id选择器会全部获取这些元素,js中的id获得器则根据上下文顺序只会获取第一个元素
HTTP三点注意事项：
1.HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
2.HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。
3.HTTP是无状态(所以需要session和cookie来记住状态)：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。



<br />换行标签
<hr />加一根水平线
JS(内置大量对象,无需编译,由浏览器引擎(内核)逐行执行):
1.客户端的数据运算
2.客户端表单数据验证
3.浏览器事件触发
4.网页特殊效果制作
5.服务器异步数据提交(ajax)

js可以直接在事件定义时,也可以嵌入html文件中<script>,最好是引用js文件<script src="../.js">

js是解释性代码,代码错误,页面将没有效果

js事件:
1.鼠标事件
2.键盘事件
3.窗口事件
onabort	图像加载被中断	1	3	4
onblur	元素失去焦点	1	2	3
onchange	用户改变域的内容	1	2	3
onclick	鼠标点击某个对象	1	2	3
ondblclick	鼠标双击某个对象	1	4	4
onerror	当加载文档或图像时发生某个错误	1	3	4
onfocus	元素获得焦点	1	2	3
onkeydown	某个键盘的键被按下	1	4	3
onkeypress	某个键盘的键被按下或按住	1	4	3
onkeyup	某个键盘的键被松开	1	4	3
onload	某个页面或图像被完成加载	1	2	3
onmousedown	某个鼠标按键被按下	1	4	4
onmousemove	鼠标被移动	1	6	3
onmouseout	鼠标从某元素移开	1	4	4
onmouseover	鼠标被移到某元素之上	1	2	3
onmouseup	某个鼠标按键被松开	1	4	4
onreset	重置按钮被点击	1	3	4
onresize	窗口或框架被调整尺寸	1	4	4
onselect	文本被选定	1	2	3
onsubmit	提交按钮被点击	1	2	3
onunload	用户退出页面	1	2	3

事件捕获

事件冒泡
document

事件冒泡:子节点的事件出来完毕后会依次向上抛给父节点的事件函数处理;可以取消事件冒泡
e.stopPropagation();  //e表示事件对象


js事件函数:
bind(type, [data], fn)   //绑定事件函数   $obj.bind('click',function(){});可简写成$obj.click(function(e){}); 可以向点击函数传入参数e,表示事件对象event,e.target表示事件源,e.pageX,e.pageY表示点击的坐标
one(type, [data], fn)     //只执行一次的
trigger(type, [data]) 
triggerHandler(type, [data]) 
unbind([type], [data]) 
document.getElementById().addEventsListener('click',function(event){event.stopPropagation();event.stopImmediatePropagation();},true);
getEventListener(document.getElementById(""),"click");

$(selector).data("events")  ;//获取该对象的全部事件数组

jQuery对象函数:
$obj.hide();
$obj.empty();

读写节点
$obj.html();
$obj.text();
$obj.val(); //读取value属性值
$obj.attr(key); //读取key属性值  



$obj.next();      //下一个元素
$obj.sibilings();//之前的兄弟元素



infinity


js五种基本类型(原始类型primitive )：  typeof var
string boolean number null(object) undefined(undefined) (null和undefined是特殊的数据类型)
还有2种复合数据类型:function和object (Array,Map,Set(IE不支持Set)) 
string
number
boolean
function
object (包括null,array,map)
undefined

js对象
Date
Function


表格:
单元格边距(表格填充)
(cellpadding) -- 代表单元格外面的一个距离,用于隔开单元格与单元格空间单； 元格间距(表格间距)
(cellspacing) -- 代表表格边框与单元格补白的距离,也是单元格补白之间的距离。 
<input type="button" value="按钮" onclick="f1();" />
等价于<button onclick="f1();">按钮</button>

原生ajax请求
var xmlhttp;
	if (window.XMLHttpRequest)
	{
		//  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码
		xmlhttp=new XMLHttpRequest();
	}
	else
	{
		// IE6, IE5 浏览器执行代码
		xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
	}
	xmlhttp.onreadystatechange=function()  //回调函数
	{
		if (xmlhttp.readyState==4 && xmlhttp.status==200)
		{
			document.getElementById("myDiv").innerHTML=xmlhttp.responseText;
		}
	}
	xmlhttp.open(type:"GET",url:"/try/ajax/ajax_info.txt",asyn:true);   //open() 方法用来初始化 HTTP 请求参数,但是并不发送请求。
	//xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded"); //post请求需要自己设置请求头
	xmlhttp.send(null);  //get请求最好直接传null,参数放在url路径上,也可以直接不传参数,但兼容性不好
						//post请求在这里传递参数,格式是string字符串,按照key=value&key=value的格式传递
$.ajax({ url:'findById',  type:'GET',  data:{'id':$('#cb1').val()}, dataType:'json', success:function(data,statusText){  }, error:function(xhr,e1,e2){ } });

}

}



Spring{
扫描包内(包括子包)所有包含注解Component的类并添加到spring框架管理
<context:component-scan base-package=""/>
<mvc:annotation-driven/> MVC的相关注解比如@RequestParam才生效



所有的对象都可以被设为bean元素,比如class,集合<util:list id="">.
创建对象的方式(反射机制强行创建对象(无视权限))
	1.无参构造<bean id="" class=""/>  (name属性废弃不用了,class必须是带包名的class文件路径)
	2.静态工厂方法(必须有static修饰,否则报错)创建对象<bean class="" factory-method=""/>
	3.实例工厂方法<bean factory-bean="bean_id"  factory-method=""/>

scope="singleton"(默认)  |"prototype" (原型)

lazy-init="false" (默认) |"true" 
	
配置文件<bean>标签属性
<bean  id="date(唯一约束)"  class="java.util.Date(带包名的类路径名)" scope="singleton(不写默认,单例模式,)| prototype() "
	lazy-init="true(默认为false,单例模式下自动创建对象)"	init-method="初始化自动调用的方法名"  destroy-method="方法名 容器关闭前调用此方法销毁对象(只在单例模式下有效)"
    />
描述Spring框架的作用和优点。
Spring框架的作用和优点如下：
1. Spring是一个开源的轻量级的应用开发框架，其目的是用于简化企业级应用程序开发，减少侵入；
2. Spring提供的IoC和AOP应用，可以将组件的耦合度降至最低，即解耦，便于系统日后的维护和升级；
3. Spring为系统提供了一个整体的解决方案，开发者可以利用它本身提供的功能外，也可以与第三方框架和技术整合应用，可以自由选择采用哪种技术进行开发。


静态工厂方法创建对象factory-method=""(该方法必须是static修饰的,否则就没有意义)

scope="singleton"|"prototype"|"session"|"request"|"global Session"

lazy-init属性对原型无效(scope="prototype")
destroy-method属性只对单例(singleton)有效

init-method属性对原型有效,在创建对象时自动调用

set方法注入(最常用),class中setXxxx(Object o)方法必须是public修饰的
构造器注入,无视构造方法的访问权限
autowise:自动装配 表示容器自动建立对象之间的依赖关系 byName:依据属性名(bean id)查找相应的bean( 以属性名作为bean的ID来查找,找到之后调用set方法来建立依赖关系) 
		最终还是采用set方法 tips:如果找不到则不注入 byType:依据属性的类型来查找相应的bean,找到之后,调用set方法
		通过类型查找到两个或两个以上的bean则会不报错,特别是存在继承,实现关系的父子类上,同时符合父类 -->
		<!-- constructor:与byType类似,通过类型查找匹配的bean对象,在多态环境下容易发生异常(匹配到多个合适的bean)只不过调用构造器来注入 -->
		<!-- 默认不注入 -->

autowire="no"(默认)|"byName"|"byType"|"constructor"|"autodetect"

<util:properties location="classpath:config.properties">


组件扫描
<context:component-scan base-package="包名"/>

<mvc:annotation-driven/>
<bean id='' class="" scope="" lazy-init=""    autowire="byName"  init-method="" destroy-method="">
@Component("")      @Scope("")     @Lazy("")  @Autowired  --@Qualifier("id") 
@Postconstruct    @PreDestroy

spring框架可以自动向处理器的处理方法传入request,session,和ModelMap对象


}





{
数据库SQL对于空字符串与null的情况返回的结果都是空的集合

向数据库传入空字符串,该字段结果为空,不为null;
	
JAVA空指针与空字符串的问题:
Integer.parseInt(null);//异常
Integer.parseInt("");//异常
System.out.println("".equals(null));  //false
//System.out.println(null.equals(""));  //编译错误  运行时空指针异常
System.out.println("xxx".equals(null));//false
System.out.println("xxx".equals(""));//false

		public User findByName(String name, String pwd)
			throws UserNotFoundException, PasswordNotCorrectEception {
		//判断空指针与空字符串的情况
		if(pwd==null||pwd.trim().isEmpty()) throw new PasswordNotCorrectEception("密码不能为空");
		User user=userDao.findByName(name);
		if(user==null) throw new UserNotFoundException("用户名错误");
		if(!user.getPassword().equals(pwd))throw new PasswordNotCorrectEception("密码错误");
		return user;
	}
	
	
	

}


反射{
1.Class c=Class_Name.calss;//使用泛型明确class类型(不会初始化)
2.Class c=Object.getClass();//同过实例对象获取class对象
3.Class c=Class.forName(String path);//通过class文件的路径获取class文件对象

Constructor Class.getDeclaredConstructors()
反射可以获取从父类继承,以及自己的全部公开的方法;
反射可以获取自己的全部方法(包括private,但是不能获取父类继承的方法);
未被重写的方法,实际上是去加载父类并调用父类的方法,需要考虑访问权限的问题.

protected Object Object.clone();
不重写该方法:只能在子类的成员方法中通过super关键字调用,(前提:在本类中)或者通过该子类对象的引用去调用



}


匿名内部类; 
 * 适合创建那种只使用一次的类，创建匿名内部类时会创建该类的实例，类定义立即消失，匿名内部类不能重复使用 
 * 必须继承一个父类或者实现一个接口，但是只能继承一个父类或者实现一个接口 
 * 还有2点注意 
 * 第一  匿名内部类不能是抽象类，因为抽象类不是实例化，而内部类要创建类的实例 
 * 第二  不能定义构造器，因为没有类名，但是可以定义实例初始化 
 *  
内部类可以另外继承或实现其他的类或接口
//(引用类型)强转编译不报错,运行时刻可能报错(子类引用指向父类对象运行抛出异常)
//子类可以拥有与父类同名的变量
//Fu f=new Zi();  等同于  Fu f=new Fu();  Zi z=new Zi();  f=z;(无需强转)
public class Zi extends Fu{
int i=3;
	public static void main(String[] args) {
		Fu f=new Zi();
		System.out.println(f.i);  //输出父类的变量i=1
		Zi z=new Zi();
		f=z;  //向上造型
	}
}
class Fu{
	int i=1;
	
}

{
	class Pet{
	 int x=0;}
	class Cat extends Pet{
	int x=0;  //子类可以拥有与父类同名的变量
Pet c= new Pet();
Cat p=  (Cat)c;}   //子类引用指向父类对象编译不报错,运行异常(强转)
}

//子类接口可以写出父类接口的同名抽象方法;而子接口的实现类只需实现一个方法即可
//子类接口的方法可以重载父类接口方法
interface Fu{
	void say();
}
interface Zi extends Fu{
	void say();
}
class x implements Zi{
	@Override
	public void say() {
	}
}

 
 Java中方法绑定有哪些形式？
    A.编译时刻绑定(static ,final,private)
    B.运行时刻绑定
    
    
  表达式"hello" instance of String返回的值是哪项？//true
  
	(List l=new ArrayList();
	l.add(1);
	l.add(2);
	for(Iterator it=l.iterator();it.hasNext();){ 
	//不使用泛型也能强转为Integer list加不加泛型迭代器取出来的都是Object对象
		Integer o=(Integer) it.next();
		System.out.println(o);  
	})
	
	编译时刻绑定的方法: 
	A．静态方法
    B. private方法
    C．final方法
	
关于try...catch...finally结构，描述正确的是哪项？  
		try{}finally{}   //正确
		try{}catch(Exception e){} //正确
		try{}//错误
AJAX{
AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。
AJAX 不是新的编程语言，而是一种使用现有标准的新方法。
AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。
AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。
}

{
在 PHP 中,有两种基本的输出方法:echo 和 print;
echo - 能输出一个以上的字符串;
print - 只能输出一个字符串,并始终返回1


Razor 是一种将基于服务器的代码添加到网页中的标记语法;
Razor 具有传统 ASP.NET 标记的功能,但更容易使用并且更容易学习;
Razor 是一种服务器端标记语法,与 ASP 和 PHP 很像;
Razor 支持 C# 和 Visual Basic 编程语言;所以选D
}

MyBatis{
 SqlSessionFactoryBuilder sfb=new SqlSessionFactoryBuilder();
 SqlSessionFactory sf=sfb.build(InputStream config);
 SqlSession ss=sf.openSession();//自带commit();rolllback（）；
 
 DefaultSqlSession(SqlSession接口的实现类)
 DefaultSqlSessionFactory(DefaultSqlSessionFactory接口的实现类)
 
 
 SqlSessionTemplate(实现了SqlSession接口,用户spring框架)
 SqlSessionFactoryBean
 MapperScannerConfigurer
 
 EmpDao dao=ss.getMapper(class<T>);

 @Param("id") String str
 映射文件中主要通过Param中的id来辨别参数
 如果是多个参数且参数的数据类型不一致，那么就不要写parameterType
 如果是多个数据类型相同的参数（数组，链表），paramterType="集合中元素的数据类型"，也可以不写
 
<insert  useGenarateKeys="true" keyProperty="">
 
需要手动关闭SqlSession对象,需要手动提交事务

映射文件
Mapper映射器:符合映射文件要求的接口(Dao类的接口)
SqlSession.getMapper(class<T>);

spring框架集成MyBatis(主要方式)
springjdbc: JdbcTemplate

6个包:spring框架2个包:spring-webmvc,spring-jdbc
	  jdbc连接池2个包:ojdbc,dbcp,
	  MyBatis两个包:mybatis,mybatis-spring

		SqlSessionFactoryBean
			dataSource
			mapperLocations
		MapperScannerConfigurer
			<property name="sqlSessionFactory" ref="sqlsf"/>
			<property name="basePackage" value="dao"/>
			[<property name="annotationClass" value="annotations.MapperAnnotation"/>]


Spring框架集成MyBatis(方式二)
SqlSessionTemplate


}


spring-jdbc{
	JdbcTemplate
	RowMapper
	
	
}


Ajax{
asynchronous javascript and xml
异步的js和xml
异步请求,接受响应时不会刷新页面

getResponseHeader();
getAllResponseHeaders();

json
用来代替xml的轻量级数据传输格式
跨平台(语法借鉴了js),封装数据
解析快

ajax对象属性:
onreadystatechange
readyState(0(请求未初始化),1(已连接服务器),2(请求发送成功),3(请求处理中,正在获取数据),4(获取了所有响应数据))
status(200(请求成功),302,400,404,500)
responseText
responseXML

缓存问题:发送get请求时,有的浏览器(IE)不会在向服务器发送相同的请求(同url),而是直接从缓存中提取数据.  (空内容的post方法会发送)不上传数据的post方式可以不用写请求头
post方式上传数据不设置消息头服务器无法读取数据


编码问题:get:   xhr.open('get',encodeURI(uri),true);
		post:

缓存问题:使用随机数添加URL后缀

<script type="text/javascript">



//1.获取ajax对象
function getXHR(){
var xhr;
//大部分浏览器都是支持的
if(XMLHttpRequest){
xhr=new XMLHttpRequest();
}
//老古董IE不支持
else{
	xhr=new ActiveXObject("MicroSoft.XMLHTTP");
}
return xhr;
}
</script>

//2.创建请求(get方式和post方式)
创建请求方法send(String method,String servletpath,boolean asynchronous)中
第三个参数为true:表示ajax对象发送请求和接受数据后不会销毁当前页面,用户可以操作当前页面
第三个参数为false:表示ajax对象发送请求和接受数据后不会销毁当前页面,但是当前页面被锁定,无法操作

1.get方式
xhr.send("get","url",true);  


//按照协议要求post请求必须带消息头,而ajax对象默认不会添加消息头
//post方法需要手动添加请求头
xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");



发送请求
xhr.send(null);//get方式请求最好加上null,如果什么都不写的话浏览器可能会不兼容

xhr.send("adminCode=亚索&pwd=1234");

网络通信


json
javascript object notation 声明
轻量级的数据交换格式(json借鉴了javascript的部分语法)
比xml空间占用小,读取速度快
数据交换:

java对象----------js对象





jQuery封装ajax对象:
url:
type:
data:
dataType:json字符串  经过JSON.parse(String json)来获取json对象数组
		 text  
		 html
		 xml  (一般用json代替)
		 script  js脚本
success  绑定请求成功的回调函数
		
		//obj表示服务器返回的数据(如果是json字符串,自动转换成json对象
		function (obj){
		}
		
error:  处理错误


$(obj).load("getPrice.do","flight="+flight);

//对象属性的先后顺序无所谓
$.ajax(xhrobj);  //$.ajax(xhrobj)方法
var xhrobj={"url":"  ",};

取特殊的key值比如关键字,数字   if,
list[0]["if"]
list[0]["88"]






//方式一:直接定义ajax对象
$.ajax({"url":"random.do","type":"get","dataType":"text","success":function(data){
		$("#show").val(data);
	}});
	
						method(post/get)
						//{"url":xxx}对象
$.ajax({"url":"check.do","type":"get","data":"adminCode=king"});


//方式二:
					//请求参数
$obj.load(String url[,data]);  //默认会将服务器放回的数据写在obj.innerHTML  input无效 需要使用回调函数 调用val();
$obj(url,data,function(x){});  //这里的x表示的是服务器返回的数据

$getJson(url,data,function(){});


$(selector).load(url,data,callback) 把远程数据加载到被选的元素中 
$.ajax(options) 把远程数据加载到 XMLHttpRequest 对象中 
$.get(url,data,callback,type) 使用 HTTP GET 来加载远程数据 
$.post(url,data,callback,type) 使用 HTTP POST 来加载远程数据 
$.getJSON(url,data,callback) 使用 HTTP GET 来加载远程 JSON 数据 
$.getScript(url,callback) 加载并执行远程的 JavaScript 文件 

(selector) jQuery 元素选择器语法

(url) 被加载的数据的 URL（地址）

(data) 发送到服务器的数据的键/值对象

(callback) 当数据被加载时，所执行的函数

(type) 被返回的数据的类型 (html,xml,json,jasonp,script,text)

(options) 完整 AJAX 请求的所有键/值对选项




Map显示的结构与entity类一样
{key:value}形式

list,数组都是  [{},{}]  ["","",""]

[{"age":5,"name":"Tom","price":4.5},{"age":6,"name":"Som","price":5.5}]

JSON是javascript的一部分
JSON是javascript的对象直接量语法,用于声明js对象
JSON字符串:符合JSON语法的字符串

//创建对象,创建数组

var obj={age:5,name:'TOM'}; //声明对象直接量

var ary=[1,"2",3,true];  //声明数组对象

var str='{"name":"TOM","age":6}';
var str='[{"name":"TOM","age":6},{"name":"SOM","age":7}]';

JSON字符串转换成json对象
//宽松版容易出BUG  直接调用eval(str);方法容易错误
JSON字符串转换成json对象   var str=xhr.responseText;
var jsonObj=JSON.parse(str);  //JSON.parse(String str)的底层是eval()函数

json可以存储对象,数组,字符串


//严谨写法
var obj=eval('('+str+')');  //加双括号



String 
public int compareTo(String anotherString) {
        int len1 = value.length;
        int len2 = anotherString.value.length;
        int lim = Math.min(len1, len2);
        char v1[] = value;
        char v2[] = anotherString.value;

        int k = 0;
        while (k < lim) {
            char c1 = v1[k];
            char c2 = v2[k];
            if (c1 != c2) {
                return c1 - c2;
            }
            k++;
        }
        return len1 - len2;
    }

// 自定义异常:可以继承自Exception或者RuntimeException


存储过程,存储函数,触发器

监听器,过滤器,拦截器



Object.writeValueAsString(Object o);//底层调用了反射机制获取对象属性(包括私有属性和从父类继承的属性)
//只会获取属性,不会获取方法


存储方式:
内存:
外存的文件:
外存的数据库:
外存的数据库:

内存:瞬态,分配对象(数据-对象),
外存:  数据库(管理文件的软件)(硬盘文件) DBMS提供了并发管理,适合多线程访问
写文件是一个线程,读取文件是多个线程
//文件只能单线程访问

数据结构:
数组;链表,哈希表,枚举


mysql  -u用户名 -p密码
mysql  -uroot  -p zzanywn

数据库来管理数据库(存用户名,密码,存储过程等等长久文件数据)
查询数据库  show database//

创建数据库对象: createt database db_name//
drop database db_name//


ENGINE=InnoDB DEFAULT CHARSET=utf8;
set names utf8  	--(mysql不能加'-'  utf8)
source file_path   --执行sql文件里面的命令

{
//apache,junit eclipse自带
	
spring-webmvc
spring-jdbc

mybatis
mybatis-spring

ojdbc || mysql
dbcp  2个包 或者c3p0

jsckson 3个包 或者 gson


<dependencies>
	<dependency>
  		<groupId>jstl</groupId>
  		<artifactId>jstl</artifactId>
  		<version>1.2</version>
  	</dependency>
	
  	<dependency>
  		<groupId>org.springframework</groupId>
  		<artifactId>spring-webmvc</artifactId>
  		<version>3.2.8.RELEASE</version>
  	</dependency>
  	
  	<dependency>
			<groupId>commons-dbcp</groupId>
			<artifactId>commons-dbcp</artifactId>
			<version>1.4</version>
		</dependency>
		
		<dependency>
  	<groupId>org.mybatis</groupId>
  	<artifactId>mybatis</artifactId>
  	<version>3.2.8</version>
  </dependency>
  <dependency>
  	<groupId>org.mybatis</groupId>
  	<artifactId>mybatis-spring</artifactId>
  	<version>1.2.3</version>
  </dependency>
  <dependency>
  	<groupId>org.springframework</groupId>
  	<artifactId>spring-jdbc</artifactId>
  	<version>3.2.8.RELEASE</version>
  </dependency>
  
  <dependency>
  <groupId>mysql</groupId>
  <artifactId>mysql-connector-java</artifactId>
  <version>5.1.6</version>
</dependency>
  
  <!-- jackson3个包 -->
  <dependency>
  		<groupId>com.fasterxml.jackson.core</groupId>
  		<artifactId>jackson-annotations</artifactId>
  		<version>2.2.3</version>
  	</dependency>
  	<dependency>
  		<groupId>com.fasterxml.jackson.core</groupId>
  		<artifactId>jackson-core</artifactId>
  		<version>2.2.3</version>
  	</dependency>
  	<dependency>
  		<groupId>com.fasterxml.jackson.core</groupId>
  		<artifactId>jackson-databind</artifactId>
  		<version>2.2.3</version>
  	</dependency>
  
  </dependencies>

  DigestUtil.md5Hex(String );  //生成MD5密码  (32位字符)
  UUID.randomUUID().toString();//自动生成唯一ID
  
  
    .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar
    bin,jre/bin
	
	
	//返回部分数据,用map封装部分字段
	JSON : list<Map<String,Object>>,List<Object>,Object
	//map取出的属性是无序的LinkedHashMap
}



{
	MyBatis框架对于可能查出多条记录但是返回值只有一个的情况会报异常
	新加入映射文件的(sql)语句必须
	泛化,把子类共有的属性和方法抽象到父类种,把该父类抽象
	
	$obj.on('click','selector',(function(){}));
	
	load是jQuery的异步方法,用来在加载网页
	异步加载网页
	
	window代表浏览器对象
	
	断点测试
	变量的值 变化  (Local内存值变化)
	
	实体类的属性名更应该和前端传进来的属性名相同,方便spring框架获取数据,封装对象
	实体类的属性还应该和数据库的字段名相同,方便查询,否则就要使用别名或者resultMap
	
	


数据结构(集合)
数组
链表()




算法(排序,查找)  
冒泡排序
二分法
快速查找


整数,小数
正数,负数

Integer.toBinaryString(int x);//转换成2进制
只有Integer和Long有解析数字成二进制的算法(方法)

所有底层的计算都是以二进制数的形式进行的,二进制数的补码
原码的
反码
补码


-n=~n+1
一个整数的负数等于该数取反+1


unicode 3.2  ucs char 类型 0~65535
超过的部分直接用int代替
String str=String.format("%010d",int x);


负数的>>操作(实际上是除以2^n):右移多少位就在最前面补多少位1  (小数的话向下取整数)
>>>的操作,无视正负数,最高位全部补0  负数>>>x会得到很大的正数
左移右移的优先级高于&高于|
<<,>>,>>> 高于 &  高于 ^ 高于 | 

float小数
指数,小数
Integer.toBinaryString(Float.floatToIntBits(float));

面向对象:
封装
继承
多态

js里声明的全局变量和方法其实都是window的属性和方法,与document无关

js
创建对象
设置属性
增删改查属性

js对象没有封装性,因为对象的属性可以随意增删
js不是面向对象的语言,只是基于对象;
js 对象的底层实际上是一个散列表,添加对象属性相当于直接put(key,value);
删除属性相当于remove(key);
访问对象属性相当于get(key);
//删除对象属性
delete obj.attr;
//添加对象属性  直接赋值
obj."key"="value";
//访问属性
obj.age
obj.say();//调用方法

<li class="disable">
	<a >
		<i class="fa fa-file-text-o cashNote" title="online" rel="tooltip-bottom"></i> [noteTitle]
		<button type="button" class="btn btn-default btn-xs btn_position btn_delete"><i class="fa fa-times"></i>
		</button>
		<button type="button" class="btn btn-default btn-xs btn_position_2 btn_replay"><i class="fa fa-reply"></i>
		</button>
	</a>
</li>';


//向jsp页面传值问题
1.数据绑定到request对象转发到jsp页面(返回值为String jsp_name)
2.数据绑定到map,封装到ModelAndView对象里发送过去(返回 new ModelAndView(String jsp_name,map))
3.数据绑定到ModelMap  ModelMap.addAttribute(String,Object);//底层还是利用request增加attribute
4.直接使用注解@ModelAttribute(String key)

spring重定向:
1.
public String handle(){
	return  "redirect:xxxxxx";
}
2.
public ModelAndView handle(){
	return new ModelAndView(new RedirectView("xxxx"));

	
	
HTTP 1.0 短连接 ----->HTTP 1.1 长连接
HTTPS 安全机制
过滤器和拦截器都需要单独写入配置文件
拦截器也可以写入注解@Component  组件扫描(不是必须的) 但在注册bean时写成<ref bean=""/>必须写
也可以单独注册,<bean class="lk.note.interceptors.AccessInterceptor"/>不用写注解(不必要)

seesionId 在浏览器都存在cookie

//心跳监测
浏览器加一个脚本,定时发送请求服务器,使session一直保存.


静态执行
动态执行


反射API
动态创建对象
可以创建任何对象

如果没有父类了,Class.getSuperClass()方法返回null

//获取该方法的注解接口对象(返回null说明没有该注解)
Method.getAnnotationByType(Class<T> annotationClass);


反射的应用:
反射需要查找.class文件,耗时,容易出错,性能差
1.Eclipse的快捷键导出public属性和方法(包括父类的)
2.spring框架:bean对象的生成(singleton,调用构造方法(私有构造也行))
	动态加载类
	动态创建bean
	动态注入属性(包括私有属性注入)  (一般调用get,set方法)
	动态解析注解
3.myBatis 
实体类只会调用无参构造方法
获取设置属性优先调用get,set方法,没有才用反射
利用反射获取实体类的属性(没有get方法也行,有get方法直接调用get方法,没有get方法直接利用发射获取属性)
查询的时候,利用反射将查询结果注入实体对象中
创建实体类对象,将查询到的结果调用set方法注入属性


静态代理:编译期就确定了

动态代理:运行期确定


AOP面向切面编程(解耦,在不修改源代码的情况下给程序动态添加统一功能的技术(0侵入),如日志记录,运行时间,事务管理,权限管理等)
基于性能测试
底层是jdk动态代理(基于反射):动态创建类,动态调用方法
对于有实现接口的类,默认采用jdk的动态代理,对于没有父接口的类,采用cglib
jdk动态代理的实现依赖一个接口InvocationHandler和一个静态类Proxy
Proxy.newProxyInstance(targetObject.getClass().getClassLoader(),targetObject.getClass().getInterfaces(),
new InvocationHandler(){public Object invoke(Object proxy,Method method,Object...args){}})

cglib:
一个接口MethodInterceptor.interceptor()



//创建代理对象,调用代理对象的方法




aop.@Before
us.findByName()
aop.@After
aop.@AfterReturning
//没有异常,先执行finally,在执行return


????
aop.@Before
us.findByName()
aop.@After
aop.@AfterThrowing
//有异常,先执行

try{
	@Before
	
	业务层方法
	
	@AfterReturning
	
	
}catch(Throwable t){
	@AfterThrowing
	
}finally{
	@After
}


around.业务方法执行前
aop.@Before
us.findByName()
around.业务方法执行后
业务方法执行后的结果为:User [id=ea09d9b1-ede7-4bd8-b43d-a546680df00b, name=yasuo, password=7908836f4219f9c41500829b164ddd6c, token=null, nick=null]
aop.@After
aop.@AfterThrowing




@Before

@Transactional//需要进行事务处理的
DML
update
delete
insert

@AfterReturning

@AfterThrowing

@After



@Component
@Aspect 
public class Demo1Aspect {

    /**
     * 环绕通知 方法:
     *  1. 必须有返回值值Object
     *  2. 必须有参数  ProceedingJoinPoint
     *  3. 必须抛出异常
     *  4. 需要在方法中调用  jp.proceed()
     *  5. 返回业务方法的返回值
     * @param jp
     * @return 
     * @throws Throwable
     */
    @Around("bean(userService)")
    public Object test5(ProceedingJoinPoint jp)
        throws Throwable{
        Object val = jp.proceed();
        System.out.println("业务结果:"+val);
        throw new UserNotFoundException(
                "就是不让登录");
    }

}
execution(User lk.note.service.UserService.findByName(String,String))
around.业务方法执行前
aop.@Before
us.findByName()
around.业务方法执行后
业务方法执行后的结果为:User [id=ea09d9b1-ede7-4bd8-b43d-a546680df00b, name=yasuo, password=7908836f4219f9c41500829b164ddd6c, token=null, nick=null]
aop.@After
aop.@AfterReturning
JsonResult(Object o)




拦截器可以测试整个请求-响应完成过程的时间
aop可以测试业务层(最耗时的操作)的完成过程时间

$Proxy

代理对象只能一个一个的调用方法,直接通过getMethods();方法获取的方法数组无法直接被proxy对象调用
NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not available [native method]


Object...args如果不传入参数,则args依然存在,只不过长度为0


代理类是公共的、最终的，而不是抽象的。 
未指定代理类的非限定名称。但是，以字符串 "$Proxy" 开头的类名空间应该为代理类保留。 
代理类扩展 java.lang.reflect.Proxy。 
代理类会按同一顺序准确地实现其创建时指定的接口。 
如果代理类实现了非公共接口，那么它将在与该接口相同的包中定义。否则，代理类的包也是未指定的。注意，包密封将不阻止代理类在运行时在特定包中的成功定义，也不会阻止相同类加载器和带有特定签名的包所定义的类。 
由于代理类将实现所有在其创建时指定的接口，所以对其 Class 对象调用 getInterfaces 将返回一个包含相同接口列表的数组（按其创建时指定的顺序），对其 Class 对象调用 getMethods 将返回一个包括这些接口中所有方法的 Method 对象的数组，并且调用 getMethod 将会在代理接口中找到期望的一些方法。 
如果 Proxy.isProxyClass 方法传递代理类（由 Proxy.getProxyClass 返回的类，或由 Proxy.newProxyInstance 返回的对象的类），则该方法返回 true，否则返回 false。 
代理类的 java.security.ProtectionDomain 与由引导类加载器（如 java.lang.Object）加载的系统类相同，原因是代理类的代码由受信任的系统代码生成。此保护域通常被授予 java.security.AllPermission。 
每个代理类都有一个可以带一个参数（接口 InvocationHandler 的实现）的公共构造方法，用于设置代理实例的调用处理程序。并非必须使用反射 API 才能访问公共构造方法，通过调用 Proxy.newInstance 方法（将调用 Proxy.getProxyClass 的操作和调用带有调用处理程序的构造方法结合在一起）也可以创建代理实例。 


violation 违反
moudle 模件

spring模式,框架,技术

声明式事务  ---->  aop   ----->  动态代理  ----->  反射

(事件冒泡)
事务传播
一个业务处理方法的事务传播到另一个业务处理方法的事务
事务的整合

数据库并发操作(读锁/写锁)
隔离级别
serializable（串行化）：可避免 脏读、不可重复读、虚读情况的发生。
repeatable read（可重复读）：可避免 脏读、不可重复读， 不可避免 虚读。mysql采用可重复读。
read committed（读已提交）：可避免 脏读，不可避免 不可重复读、虚读。oracle采用读已提交。
read uncommitted（读未提交）：不可避免 脏读、不可重复读、虚读。


1.串行化(序列化) 最高级别的隔离,效率最低,最安全(每个线程(事务)之间按顺序执行,一个事务结束后另外一个事物才能执行)
2.可以重复读取()
3.读取提交后的数据(修改状态的数据读不到)//默认(并发和安全的平衡选择) 可以同时开启读和写的事务,但只能读取写入操作中提交的数据,可能在一次读的事务中,
4.可以读取修改中(未提交的数据)的数据(脏读)


1.脏读
2.不可复读(update操作,删除)
3.幻读(删除插入操作)


http 1.1
http 2.0
http文件如何下载
html,css,js,media,text,xml,image,json

ByteArrayOutputStream 存在内存的临时性的字节输出流

initator

<image title="鼠标悬浮时显示文字" alt="图片丢失时显示的描述信息" src="直接写请求,发送get请求获取图片"/>


显示图片：直接设置
@RequestMapping(value="",produces="image/png" )

下载图片
@ResponseBody
	//@ResponseBody会自动处理控制返回值,如果是javabean对象,自动把该对象转换成json字符串
	//如果是byte[]数组,则将该数组直接封装进响应的消息body
	//这里的produces="image/png" 相当于 resp.setContentType("image/png");
	@RequestMapping(value="/downImage.do",produces="application/octet-stream")
	public byte[] downloadImg(HttpServletResponse resp) throws IOException{
	//这里必须写名响应头  filename表示下载的文件名字
	resp.setHeader("Content-Disposition", "attachment;filename=\"img.png\"");
		return createImg1();
	}
	
response.setContentType("test/html");
//识别不了的类型,全部按文件下载,文件名为域名

excel文件下载
需要导包poi
<dependency>
  <groupId>org.apache.poi</groupId>
  <artifactId>poi-ooxml</artifactId>
  <version>3.13</version>
</dependency>


工作库,工作表,行和列
//创建Excel文件
	private byte[] createExcel()throws IOException{
//		us.
		//把数据库的数据存入Excel文件
		
		//1.创建工作库(Excel文件)
		HSSFWorkbook workbook=new HSSFWorkbook();
		
		//2.创建工作表
		HSSFSheet sheet=workbook.createSheet("demo");
		
		//3.创建数据行  
		HSSFRow row=sheet.createRow(0);
		
		//4.创建数据列(格子)
		
		HSSFCell cell=row.createCell(0);
		cell.setCellValue("HelloWorld");
		
		//把Excel文件保存为byte数组
		ByteArrayOutputStream out=new 
				ByteArrayOutputStream();
		workbook.write(out);
		
		return out.toByteArray();
	}
	
//接收上传的文件
	@ResponseBody
	@RequestMapping("/upload.do")
//spring利用MutipartFile接收上传的文件 文件中的一切数据 对象的引用名字必须和表单提交文件的name属性值保持一致
public JsonResult upload(MultipartFile userFile1,MultipartFile userFile2) throws IOException{
		System.out.println("/upload.do");
		
		String file1=userFile1.getOriginalFilename();//获取完整的文件名(包括文件类型信息)
		String file2=userFile2.getOriginalFilename();
		System.out.println(file1);
		System.out.println(file2);
	//保存文件到服务器本地
		//1.userFile1.transferTo(目标文件) 可以处理大文件
		//2.userFile1.getBytes();  获取文件的全部数据,将文件全部读取到内存中,适合读取小文件
//		byte[]bs=userFile1.getBytes();
//		bs=userFile1.getBytes();
//		PrintWriter pw=new PrintWriter(new BufferedOutputStream(new FileOutputStream(""),"utf-8"));
		
		//3.userFile1.getInputStream();  获取上传文件的流,适合处理大文件(transferTo的底层就是)
		
		File dir=new File("d:/file");
		dir.mkdir();
		/*userFile1.transferTo(new File(dir,file1));
		userFile2.transferTo(new File(dir,file2));*/
		
		
		BufferedInputStream is=new BufferedInputStream(userFile1.getInputStream());
		BufferedOutputStream bs=new BufferedOutputStream(new FileOutputStream("d:/file"+file1));
		int x=-1;
		while((x=is.read())!=-1){
			
		}
		
		
		
		System.out.println("文件保存完毕");
		return new JsonResult(true);
	}

	
	The current request is not a multipart request
	
	
ea09d9b1-ede7-4bd8-b43d-a546680df00b


List<Map<String, Object>>findNotes(@Param("user")String arg0,@Param("notebookId")String arg1,@Param("statusId")String arg2);

<select id="findNotes" resultType='map'>
select cn_note_id noteId ,cn_note_title as noteTitle from cn_note
<!-- 去除多于的and -->
<trim  suffixOverrides="and" >  <!--prefixOverrides="and"  -->
<where>
<!--这里的test属性值表示的是@Param("name"),#{与前面的name相同} -->
<if test="user!=null">cn_user_id=#{user} and </if>
<if test="notebookId!=null">cn_notebook_id=#{notebookId} and </if>
<if test="statusId!=null">cn_note_status_id=#{statusId} and </if>
</where>
</trim>
order by cn_note_last_modify_time desc
</select>


Mybatis
替换表名,字段名,关键字,用${}绑定

多表关联查询

${} sql语句的拼接 (必须小心使用,有可能造成sql注入)  可以用来传入表名,字段名
#{} PreparedStatement传入参数
所有基本数据类型都用他的包装类

insert into table () values(),(),();//一次插入多条记录


useGenarateKeys="true"


js使用<input type="file" />表单空间直接上传文件
function ajaxUpload(){
	var file1 = $('#file1')[0].files[0];
	var file2 = $('#file2')[0].files[0];
	//创建内存中的表单对象
	var form = new FormData();
	//添加向服务器传输的数据
	form.append('userFile1', file1);
	form.append('userFile2', file2);
	
	$.ajax({
		url:'user/upload.do',
		data: form,
		type: 'POST',
		dataType: 'json',
		contentType: false,
		processData: false, 
		success: function(obj){
			if(obj.state==1){
				$('#result').html("成功!"); 
			}
		}
	});
}

{
	
	// @ResponseBody会自动处理控制返回值,如果是javabean对象,自动把该对象转换成json字符串
	// 如果是byte[]数组,则将该数组直接封装进响应的消息body
	// 这里的produces="image/png" 相当于 response.setContentType("image/png");
	@ResponseBody
	@RequestMapping(value = "/image.do", produces = "image/png")
	
	传入图片:
	1.直接用response.getWriter();输出图片
	
	
	
}



{
反射.动态代理
JDK动态代理只能对接口做动态代理
CGlib是spring框架中更加强大的动态代理Api
1.jdk动态代理技术的实现依赖与InvocationHandler接口和Proxy实体类
2.动态代理需要一个实现InvocationHandler接口的实体类,这个类的实例化需要传入代理对象
3.动态代理对象不要获取全部方法的数组,如此调用会出错
4.Object o=new Instance();
o.getMethod(String methodName,Object...args) 这样调用只能获取引用o中的方法
o.getDeclaredMethod(String methodName,Object...args); 这样调用可以获取引用o指向的实例对象的方法

o.getMethods();可以获取实例对象和引用中的全部公开方法
//实例对象的方法
public java.lang.String proxyTest.StuDaoImp.getName(proxyTest.Stu)
public int proxyTest.StuDaoImp.getAge(proxyTest.Stu)
public void proxyTest.StuDaoImp.say()

//引用中的全部方法
public final void java.lang.Object.wait() throws java.lang.InterruptedException
public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException
public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException
public boolean java.lang.Object.equals(java.lang.Object)
public java.lang.String java.lang.Object.toString()
public native int java.lang.Object.hashCode()
public final native java.lang.Class java.lang.Object.getClass()
public final native void java.lang.Object.notify()
public final native void java.lang.Object.notifyAll()





o.getDeclaredMethods();只能获取实例对象中的全部方法(包括私有方法)
public java.lang.String proxyTest.StuDaoImp.getName(proxyTest.Stu)
public int proxyTest.StuDaoImp.getAge(proxyTest.Stu)
public void proxyTest.StuDaoImp.say()
private void proxyTest.StuDaoImp.pri()



//代理类的方法不同与被代理对象的方法,不能混调用

for(Method x:ms){
			//用实体类生成的Method数组依次调用没有问题
			//用代理类生成的Method数组会报异常
			x.invoke(ud);//没有问题
//			System.out.println(m);

//			代理类生成的数组也报异常debug
//			x.invoke(proxy);//异常  object is not an instance of declaring class
		}
//代理类的方法全部final修饰
0 : public final void com.sun.proxy.$Proxy0.add()
1 : public final boolean com.sun.proxy.$Proxy0.equals(java.lang.Object)
2 : public final java.lang.String com.sun.proxy.$Proxy0.toString()
3 : public final int com.sun.proxy.$Proxy0.hashCode()
4 : public final void com.sun.proxy.$Proxy0.update()
5 : public final void com.sun.proxy.$Proxy0.find()
6 : public final void com.sun.proxy.$Proxy0.delete()


//实体类自己的方法
0 : public void cn.itcast_06.UserDaoImpl.add()
1 : public void cn.itcast_06.UserDaoImpl.update()
2 : public void cn.itcast_06.UserDaoImpl.find()
3 : public void cn.itcast_06.UserDaoImpl.delete()

}
思想    模式
关联映射
集合创建出来的时候直接调用构造方法避免空指针异常

<计算机编程艺术>
1. tomcat:web.xml
DispatcherServlet  |StrutsPrepareAndExecuteFilter
CharacterEncodingFilter
自定义HTMLFilter(只有过滤器能过滤匹配路径以外的其他资源请求)
2. Spring: spring-*.xml



{

ApplicationContext  ClassPathXmlApplicationContext

StrutsPrepareAndExecuteFilter(Struts2主控制器)
						<!--一级目录要有/xxx,二级目录不需要/,否则报错,找不到路径  -->
<package name="demo" namespace="/demo" extends="struts-default">
        <!--由于使用Spring来管理Action，因此需要通过Spring
            容器来创建Action，因此class属性指定的是组件的ID。-->
        <action name="hello" class="helloAction">
            <result name="success">
                /hello.jsp
            </result>
        </action>
</package>


spring容器由DispatcherServlet来启动
整合struts后,主控制器由StrutsPrepareAndExecuteFilter代替,所以需要另外配置一个监听器(ContextLoaderListener)来启动spring框架
<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
  </listener>
  <context-param>
  	<param-name>contextConfigLocation</param-name>
  	<param-name>classpath:spring-*.xml</param-name>
  </context-param>

 <action name="hello" class="写class文件路径名,就是Struts管理,写bean的ID,表示有spring管理">
 <result name="ok"> /WEB-INF/xxx.jsp</result></action>
 result标签默认是转发的
 这两者都行,但spring有更强大的依赖注入和Aop事务管理
 用spring管理子处理器,必须要用原型@Scope("prototype")
Spring框架整合Struts2
Struts2主控制器StrutsPrepareAndExecuteFilter
struts2为了保证线程安全,每一个用户请求都需要单独写一个处理类,处理请求时创建对个(XxxAction)对象.每个线程独享一个子处理器的对象.
spring多请求共享一个处理器对象,spring利用参数注入解决线程安全问题
每个线程共享一个处理器对象,但传递的参数不同.
1. 如何接受用户的提交数据
	利用bean属性(特指访问对象属性的get,set方法)
	获取的数据利用set方法设置Action类中的属性值

getUv: null
setUv UserValue [name=null, password=null, age=null, address=null]
getUv: UserValue [name=null, password=null, age=null, address=qweds]
getUv: UserValue [name=null, password=null, age=32, address=qweds]
getUv: UserValue [name=yasuo, password=null, age=32, address=qweds]
execute: UserValue [name=yasuo, password=q2weds, age=32, address=qweds]
	
getUv: null
UserValue()
setUv UserValue [name=null, password=null, age=null, address=null]
setAddress
//UserValue [name=null, password=null, age=null, address=null]
getUv: UserValue [name=null, password=null, age=null, address=2额外的所]
setAge
//UserValue [name=null, password=null, age=null, address=2额外的所]
getUv: UserValue [name=null, password=null, age=23, address=2额外的所]
setName
//UserValue [name=null, password=null, age=23, address=2额外的所]
getUv: UserValue [name=yasuo, password=null, age=23, address=2额外的所]
setPassword
//UserValue [name=yasuo, password=null, age=23, address=2额外的所]
execute: UserValue [name=yasuo, password=1234abvc, age=23, address=2额外的所]


getUv: null
UserValue()
setUv UserValue [name=null, password=null, age=null, address=null]
setAddress
//UserValue [name=null, password=null, age=null, address=wedsc]
getUv: UserValue [name=null, password=null, age=null, address=wedsc]
setAge
//UserValue [name=null, password=null, age=23, address=wedsc]
getUv: UserValue [name=null, password=null, age=23, address=wedsc]
setName
//UserValue [name=wahaha, password=null, age=23, address=wedsc]
getUv: UserValue [name=wahaha, password=null, age=23, address=wedsc]
setPassword
//UserValue [name=wahaha, password=1234, age=23, address=wedsc]
execute: UserValue [name=wahaha, password=1234, age=23, address=wedsc]


Session储存数据



参数传递,直接使用Map<String,Object>map传入响应的request,session,application
StrutsPrepareAndExecuteFilter
C.ActionSupport

重写setXxxx方法
I.SessionAware
I.RequestAware
I.ApplicationAware


}

HTTP下载
<result-type name="stream" class="org.apache.struts2.dispatcher.StreamResult"/>


//展示图片
//下载图片
//下载Excel

struts原生不支持json,需要导入json的插件  struts2-json-plugin
该插件不需要再导入解析实体类为JSON字符串的包
<jsp:forward page = "newworld.jsp" ></jsp:forward>
jsp:forward可以实现页面跳转的效果 作用是转发 所以浏览器地址不会发生变化

<c:forEach items="${}" var="">


WEB Server
Apache(HTTP Server)   Nginx(HTTP Server)  Java Web 服务器(Servlet容器)Tomcat
}

jstl
//c.tld文件
JSP可以使用Struts标签,直接导入即可
<%@taglib uri="/struts-tags" prefix="s"%>
ValueStack
struts共享数据的机制,利用ValueStack可以在Struts组件之间共享数据
struts组件:
1. StrutsPrepareAndExecuteFilter
2. Action
3. result
4. 视图JSP
5. valueStack(控制器的属性存储位置)
配置文件 struts.xml

<s:property value="name" />


Element : rtexprvalue
Defines if the nesting attribute can have scriptlet expressions as a value, i.e the value of the 
 attribute may be dynamically calculated at request time, as opposed to a static value 
 determined at translation time. If not present then the default is "false", i.e the attribute has a 
 static value

Data Type : string
Enumerated Values : 
	- true
	- false
	- yes
	- no
	
OGNL(对象图导航语言)
在任何组件中
使用OGNL读取ValueStack数据的时候是按照从顶到下顺序查找,找到第一个匹配的就返回该值
尽量不要使用重复的属性名
Struts底层接管了EL和JSTL,将EL数据读取到ValueStack.EL的读取结果与ONGL一样

如果需要读取ValueStack的context区域,必须使用ValueStack  (#key)


JAVA EE是基础
spring是JAVA EE基础之上的简化框架(spring可以独立使用,但一般在JAVA EE环境中运行.JUNIT测试时是直接调用spring的)

WEB 开发需要java EE,多了两个jar包(jsp-api.jar和servlet-api.jar,定义了一些规范接口,具体需要服务器软件如Tomcat实现)

Struts(架子)
Mybatis
Spring
Hibernate(冬眠):以面向对象的方式操作数据库,不使用面向过程的sql
1. 不用写sql,但需要重新写hql(hql是基于sql的)
2. 会生成不理想的SQL,影响数据库性能
3. 特殊操作,无法实现
解决ORM问题(Object relation Mapping)对象关系映射问题
底层还是JDBC (SQL)


servlet组件如何设置文件下载(2步):
1. response.setContentType("application/octet-stream");
2. response.setHeader("Content-Disposition","attachment;filename=\"img.png\"");

处理文件上传,需要导入两个包
commons-fileupload-1.2.2.jar
另一个是commons-io-2.0.1.jar
需要限定上传文件的类型和大小: 设置上传文件的拦截器

<action name="upload" class="">
    <interceptor-ref name="fileUpload">  
    <param name="allowedTypes">  
image/bmp,image/png,image/gif,image/pjpeg,image/jpg   
                </param>

  <param name="maximumSize">2048</param>//限定图片大小不能超过2k  
         </interceptor-ref>      
		 
         <interceptor-ref name="defaultStack"></interceptor-ref>  
         <result name="error">/error.jsp</result>  
         <result name="input">/upload.jsp</result>  
</action>  



//xhr.setRequestHeader("contentType","application/");
spring-mvc中;直接设置@RequestMapping(value="url" produce="application/octet-stream");
在方法体中设置响应头:response.setHeader("Content-Disposition","attachment;filename=\"img.png\"");




struts2中,设置action标签
<action name="" class="">
<result name="ok" type="stream" >
			//	这里的值img代表action类中的inputStream img 属性
	<param name="inputName">img</param>
	<param name="contentDisposition">attachment;filename="img.png"</param>
</result>


</action>

servlet组件文件上传


//没有该属性,必有该setXxx()方法
spring-mvc需要配置上传文件解析器MultipartResolver
org.springframework.web.multipart.commons.CommonsMultipartResolver
<property name="maxUploadSize" value="10000000"/>
    <property name="defaultEncoding" value="utf-8"/>
<form method="post" action="url" enctype="multipart/form-data">
MultipartFile

var file1 = $('#file1')[0].files[0];
	var file2 = $('#file2')[0].files[0];
	//创建内存中的表单对象
	var form = new FormData();
	//添加向服务器传输的数据
	form.append('userFile1', file1);
	form.append('userFile2', file2);

	
	Struts2提供了异常处理,但是基于网页的标准错误页面提示,不太友好,需要自己设置异常处理
	
	
	{
		配置连接池
		//MyBatis映射文件扫描可以写成/mappers/*.xml来表示该文件夹下全部映射文件
		MyBatis:
		整合spring需要配置的bean:
		1. sqlSessionFactory(dataSource,mapperLocations)
		2. MapperScannerConfigurer(sqlSessionFactory,basePackage)
		//基于spring AOP的事务管理
		3. DataSourceTransactionManager(dataSource)//基于连接池管理事务 
		//设置注解驱动事务管理
		4. <tx:annotation-driven transaction-manager="dataSourceTransactionManager" />
		
		//Hibernate映射文件只能写成list,一个一个写
		Hibernate
		1. LocalSessionFactoryBean(dataSource,mappingLocations,hibernateProperties[hibernate.dialect,hibernate.show_sql,hibernate.format_sql])
		2. org.springframework.orm.hibernate3.HibernateTemplate(sessionFactory)
		////基于sessionFactory管理事务
		3. org.springframework.orm.hibernate3.HibernateTransactionManager(sessionFactory)
		//设置注解驱动事务管理
		4. <tx:annotation-driven transaction-manager="dataSourceTransactionManager" />
		
		独立使用:
		1. Configuration builder=new Configuration();
		2. builder.configure(String path);//读取配置文件
		3. SessionFactory ssf=builder.buildSessionFactory();//创建SessionFactory
		4. Session ss=ssf.openSession();
		//Hibernate 默认不提交事务,需要手动开启Transaction对象
		//Transaction ts=ss.beginTransaction();
		// ts.commit();
	
	Configuration
	SessionFactory
	Session
	Transaction
	Query
	
		@Test
	public void findAll(){
		String hql="from User";
		List<User> list=ss.createQuery(hql).list();
		for(User u:list){
			System.out.println(u);
		}
	}
	//模糊查询
	@Test
	public void search(){
		String hql="from User where name like :name";
		Query query=ss.createQuery(hql);
		query.setString("name", "%皮%");
		List<User>list=query.list();
		for(User u:list){
			System.out.println(u);
		}
	}
	
	@Test
	public void search(){
//		String hql="from User where name like :name";
		String hql="from User where name like ?";
		Query query=ss.createQuery(hql);
	// query.setString("name", "%皮%");
		query.setString(0, "%皮%");
		List<User>list=query.list();
		for(User u:list){
			System.out.println(u);
		}
	}
		@Test
	public void findByName(){
//			String hql="from User where name= :name";
//			Query q=ss.createQuery(hql);
//			q.setString("name", "皮皮揭");
//			List<User> u=q.list();
//			System.out.println(u);
			
			String hql="from User where name=?";
			User u=(User) ss.get("lk.note.entity.User", "e2e46dfa-5dd3-4659-bc5d-079abcca4d0f");
			System.out.println(u);
	}
	//违反主键约束,后面更新的记录会替换掉原来id的记录
	79069dae-cca1-4d66-bc74-069bba9dcb28 | pipijuan     | 2b72fedca21db9bfdf86b52debf9e5e5 | NULL          | 皮皮娟       |
	e2e46dfa-5dd3-4659-bc5d-079abcca4d0f | pipijuan     | 2b72fedca21db9bfdf86b52debf9e5e5 | NULL          | 皮皮娟       |	
		
		回归性测试
		以前测试过在进行测试
	}
	
	Struts2拦截器(实现com.opensymphony.xwork2.interceptor.Interceptor接口,或者继承
	public abstract class com.opensymphony.xwork2.interceptor.AbstractInterceptor implements com.opensymphony.xwork2.interceptor.Interceptor)
	拦截器栈(多个拦截器一同工作,拦截器的容器)
	//系统拦截器有很多个
	拦截器:
	1. 拦截异常
	2. 记录地区/语言 zh_CN
	3. FileUpload
	4. Parameter 参数检查(把参数放入ValueStack)  Interceptor检查参数
	5. Validation
	
	
	Struts配置文件的书写有些元素必须按顺序书写,否则会报错.
	
	CAP(Consistency,Availability,Partitiontolerance)
	
				//把查询到的部分结果装入map容器,property as key,不写key则默认为0,1,2...
	String hql="select new map(bookId as id, name as name ) from Notebook where userId=?";
		
		@SuppressWarnings("unchecked")
		List<Map<String, Object>>list=hibernateTemplate.find(hql, userId);
		return list;
	
	
	Hibernate: 
    insert 
    into
        cn_user
        (cn_user_name, cn_user_nick, cn_user_token, cn_user_password, cn_user_id) 
    values
        (?, ?, ?, ?, ?)
Hibernate: 
    update
        cn_user 
    set
        cn_user_name=?,
        cn_user_nick=?,
        cn_user_token=?,
        cn_user_password=? 
    where
        cn_user_id=?
		
		
Hibernate延迟加载对象 Session.load(Object.class,Object primaryKey),实际上使用的是代理对象(只有id属性的空壳)，如果找不到就会抛异常（ObjectNotFoundExcepption）只有需要访问该对象的其他属性是才会访问数据库
Session.get(Object.class,Object primaryKey)使用的是实体对象,如果找不到该对象返回null

无论是load还是get，返回的对象都是持久状态	  (持久状态下不会修改主键)
//IdentityGenerator(Hibernate提供的主键自增)  <generator class="identity" />


标准js创建ajax请求:
1. 创建ajax对象 var xhr= new XMLHttpRequest();
2. 设置请求参数: xhr.open(url,method,true);
3. 设置回调函数: xhr.onreadystatechange=function(data){}
3. xhr.send(null);


$.ajax({url:"",data:"",dataType:"",success:function(){},error:function(){}})
$(selector).load(url,data,callback) 把远程数据加载到被选的元素中 
$.ajax(options) 把远程数据加载到 XMLHttpRequest 对象中 
$.get(url,data,callback,type) 使用 HTTP GET 来加载远程数据 
$.post(url,data,callback,type) 使用 HTTP POST 来加载远程数据 
$.getJSON(url,data,callback) 使用 HTTP GET 来加载远程 JSON 数据 
$.getScript(url,callback) 加载并执行远程的 JavaScript 文件 



Session是接口，hibernate框架提供的实现类是SessionImpl
Hibernate中Session的
Session是轻量级的，可以随意的创建和销毁
Session不是线程安全的


exclusion 排除，拦截器排除？
spring-mvc：


文件上传需要导入2个包,commons-fileupload 和commons-io

//上传文件解析器的配置
<bean id="multipartResolver"
    class="org.springframework.web.multipart.commons.CommonsMultipartResolver">

    <!-- one of the properties available; the maximum file size in bytes -->
    <property name="maxUploadSize" value="10000000"/><!-- 十万字节(一次上传的所有文件不超过10M) -->
    <property name="defaultEncoding" value="utf-8"/>
	</bean>

延迟加载:
OpenSessionInViewFilter

Hibernate更新的弊端:
需要传入一个完整的对象实体,全部属性都根据该对象更新.而如果只提交了该对象的部分修改属性,其他属性却被修改为null了
解决方案:
1. 在提交的表单中声明哪些属性是不需要更新的
<s:hidden name="OGNL"/> (如果不需要修改的字段很多,需要重复写,很麻烦)
2. 直接在映射文件ORM.xml中关闭更新<property name="" column="" update="false"/> (永久关闭该属性的更新了,其他业务要更新却无法操作)
3. 将orm映射文件的class类设置为动态更新属性(只在属性发生改变才更新,但只对持久状态下的对象有效)
因为表单提交的数据而创建的实体对象是临时状态,需要先用get(<T>,Serializable id)获取持久状态的对象,在用Spring的BeanUtils工具类
将临时状态对象的属性复制给持久状态对象完成更新
<class name="cn.tedu.note.entity.Note" table="cn_note" dynamic-update="true">
BeanUtils.copyProperties(Object source,Object target);



response.setContentType("text/html");
MIME类型以类型/子类型（type/subtype）的形式表示。

其中type表示一下几种典型文件格式的一种：

Text、Audio、Video、Image、Application、Mutipart、Message

Subtype则用来描述具体所用的数据格式。

Application/msword

微软的Word文件

Application/octet-stream  

一种通用的二进制文件格式(包括图片)

Application/zip

Zip压缩文件

Application/pdf

Pdf文件

分布式系统中，CAP只能同时满足两个
CA
CAP定理
一致性(Consistency),可用性(Availability),分区容错性(Partition tolerance)
 

ASM

缓存一致性问题:(多线程范文同一数据)
1> 内存上锁(锁总线)
2> 缓存一致性协议:Intel 的MESI协议

js的str.replace("a","0");//把str字符串中的第一个"a"替换为"0"
js的str.replace(/a/g,"0");//把str字符串中的全部"a"替换为"0"


接收页面参数值有3种方式
	使用request
	使用@RequestParam注解  eg:  public Object handleRequest(@RequestParam("password") String pwd)
	//不写注解默认从request中直接获取变量名的数据,如果没有则取得null,可作类型转换,如果是基本数据类型取不到值得抛出异常
	//写了@RequestParam("name")如果娶不到值直接抛异常
	使用实体对象(自动把接受的数据封装成对象)

向页面传出数据有3种方式
	使用ModelAndView对象 return new ModelAndView(String url,Map map);
	使用ModelMap对象    方法传入参数ModelMap,ModelMap.addAttribute(String key,Object value);
	使用@ModelAttribute注解 使用该注解,则每次匹配请求后执行service方法前都会先调用@ModelAttribute的方法
	在Controller方法参数上直接声明HttpSession即可使用
重定向有2种方式
使用RedirectView  return new ModelAndView(new RedirectView(String path));
使用redirect:  return "redirect: url";

转发的2个方法:
1> forward(request,response); //全部委托转发页面处理请求,此方法执行之后的request,response操作将不再生效
2> include(request,response);//保留本页面继续处理的权利

Mybatis中Dao对应的方法不可重载,如需要可变的参数可用动态Sql语句




Tomcat{
Mapped "{[/test.do],methods=[],params=[],headers=[],consumes=[],produces=[],custom=[]}" onto public void cn.lk.home.Test.test(java.sql.Date)

}

spring{
web服务的相应结果若不加@ResponseBody注解,直接返回一个字符串则默认转发请求至 该字符串.jsp页面
ajax请求传递日期参数:可以将日期转成字符串,在java端重新将该字符串转换成日期.如果在对象中的日期参数,则可以在set方法传递字符串
}


//        List list = pageResult.getQueryResult();
//        double num = list.size();
//        String labelName = null;//page;//.getLabelName();
       /* if (num <= 10000) {
//            graphicBaseDao.insertMany(list, labelName);
            *//*int count = (int) Math.ceil(num / 10000);
            for (int x = 0; x < count; x++) {
                int startIdx = x * 10000;
                int endIdx = startIdx + 10000;
                if (x == count - 1) endIdx = (int) num;
                List subList = list.subList(startIdx, endIdx);
//                graphicBaseDao.insertMany(subList, labelName);
            }*//* subInsert(pageResult,100000);
        } else *//*if (num <= 100000)*//* {
            subInsert(pageResult,100000);
            *//*int count = (int) Math.ceil(num / 100000);
            CountDownLatch subSign = new CountDownLatch(count);
            for (int x = 0; x < count; x++) {
                int startIdx = x * 10000;
                int endIdx = startIdx + 10000;
                if (x == count - 1) endIdx =
                        (int) num;
                List subList = list.subList(startIdx, endIdx);
                Page subPage = null;//page.subPage();
                insert(subPage, subSign);
            }*//*
        }*/
//        graphicBaseDao.insertMany(page);


数据库{
mysql{
字符串函数、数学函数、日期时间函数、搜索函数、加密函数、信息函数。

select @@tx_ioslation;--查看当前数据库的隔离等级
set session transaction isoalation level read commit;
1.串行化(序列化) 最高级别的隔离,效率最低,最安全(每个线程(事务)之间按顺序执行,一个事务结束后另外一个事物才能执行)
2.可以重复读取//MySql默认
3.读取提交后的数据(修改状态的数据读不到)//Oracle默认(并发和安全的平衡选择) 可以同时开启读和写的事务,但只能读取写入操作中提交的数据,可能在一次读的事务中,
4.可以读取修改中(未提交的数据)的数据(脏读)

1.脏读 (read commit)//针对update操作
2.不可复读(repeatable Read)//(update操作)
3.幻读(删除插入操作)//针对delete/insert操作


grant all on *.* to 'user10'@'%';最高权限

grant select on test.* to "lk"@localhost;
revoke select on test.* from "lk"@localhost;

revoke 权限1, 权限2..... on 数据库.表 from '用户名'@'IP地址';
grant  权限1, 权限2..... on 数据库.表 to   '用户名'@'IP地址';

create user 王舞 @'localhost'  identified by 'password';--创建本地用户
create user maliu@'IntAddress' identified by 'password';--创建指定ip地址的用户
create user maliu@'%' identified by 'password';--创建本地或远程用户

use mysql;
update user  set password=password("xxx") where user="likai";
flush privileges;

//登录数据库
mysql -u root -p database_name;
use database_name;



set autocommit=0;--设置自动提交事务为false;

begin start transaction

mysql没有非空函数,使用isnull(字段,null时取出的值);



alter table emp add column_name after column_name_exists;  //把新的字段添加到已存在的字段后面



select case cn_note_status_id when "1" then "ss" when "0" then "00" else "" end from cn_note;
							if(boolean 表达式	,true , false)
select if(cn_note_status_id="1","ok","error") from cn_note where cn_note_id="fed920a0-573c-46c8-ae4e-368397846efd";

按小时分组select date_format(hiredate,"%Y%M%D%H") hour,count(*) num from emp group by hour;


//增加索引
create index idx_ename on table_name(column);
alter table table_name add index idx_name (column); 

索引是B tree ,模糊查询步骤 B tree
index full scan 可以走模糊查询

//建立临时表
create temporary table tem_table_name ();


case语句
case column when  xxx then xxx when xxx then xx  else  xxx end

}

oracle{
	like "%xxxx" 列索引失效
	index full scan
decode(column,case a,do a,case b,do b,全部不匹配默认执行);
case column when  xxx then xxx when xxx then xx  else  xxx end


笛卡尔坐标系:
表a的记录数*表b的记录数

exec dbms_stats.gather_table_stats('SYS','T1');

}

}

jdbc{
driverClass
url
user
password

数据库连接池: DataSource(配置连接池)

dbcp : BasicDataSource
c3p0:  ComboPooledDataSource
spring-jdbc：连接池　 DriverManagerDataSouce
iBatis : 	PooledDataSource
}



//常用程序的端口号
oracle: 1521
mysql: 3306
tomcat: 8080  (80)



int pos;
int size;
String next;
Enumeration<T>enumeration
while(enumeration.hasMoreElements()){
T ele = enumeration.nextElement();
}



过滤器(Filter)是基于回调,拦截器(Interceptor)是基于反射

位运算符: ^ & | ~ << >> >>>


java对象的比较排序必须要实现Comparable接口,否则会报异常:
java.lang.ClassCastException: demo04.Emp cannot be cast to java.lang.Comparable
原理:比较对象时需要用到Comparable接口的实现方法(Comparable内部比较器)

Comparator接口(外部比较器,临时创建的比较器)
比较两个对象的大小

集合框架里面用的比较多


javascript

数组排序:
js数组存放的元素可以是任意对象
var array=[1,21,11,56];
array.sort();
从数字的最高位数字开始比较,不是比较数值
需要传入比较函数
array.sort(function(a,b){return a-b;});

[null, 1, true, 2, "3", 9, 21, NaN, undefined]
null<false=0<true=1<NaN<undefined
null-NaN=NaN;

//任何数字与undefined计算结果都为NaN;

null+undefined
NaN
null+false
0
undefined+undefined
NaN

//js检查表单提交的数据
<script>
function validateForm(){
var x=document.forms["myForm"]["fname"].value;
if (x==null || x==""){
  alert("姓必须填写");
  return false;
  }
}
</script>

background-attachment 有三个值，scroll是默认值，背景图像会随着页面其余部分的滚动而移动。 fixed当页面的其余部分滚动时，背景图像不会移动。 inherit规定应该从父元素继承 background-attachment 属性的设置。 background-origin 属性规定 background-position 属性相对于什么位置来定位。 background-clip 属性规定背景的绘制区域。
字符串与数字不能进行判断,编译错误;

哈希查找的时间复杂度为O(1);
java垃圾回收机制采用分代收集,其中堆大概分为两代
 虚拟机中的共划分为三个代：年轻代（Young Generation）、年老点（Old Generation）和持久代（Permanent Generation）。

2位的十六进制数就是一个字节：0x12&0x0f结果为0x12的的后四位
 
 switch 参数类型:byte,short,int,String,char,enum,Byte,Short,Integer,Character共10种
 
 
1.数据类型
	1.1基本数据类型
	1.2引用数据类型
	
	int 与Integer对象==比较,Integer对象自动拆箱用int值比较
	
	Integer对象与Integer对象==比较,比较的是引用
	Integer对象维护了一个byte常量池,-128到127范围的值
	通过Integer i=127;Integer i2=127;这样的对象==结果为true
	
	超出范围,则为false
	其他所有new出来的地址值一般都不同
	
	
	Long 的常量池范围为Integer.MIN_VALUE~Integer.MAX_VALUE;
	
	int 转 字符串
	int x=1;
	String str=String.valueOf(x);
	String str=Integer.toString(x);
	String str=x+"";
	
	字符串转成数字:可能失败,抛出异常throw new NumberFormatException();
	String str="12";
	int x=Integer.parseInt(str);
	int x=Integer Integer.valueOf(str);//这里做了自动拆箱
	
	日期转成格式化字符串
	Date d=new Date();
	SimpleDateFormat sdf=new SimpleDateFormat();
	String str=sdf.parse(str); throw new ParseException() extends Exception;
	Date d=sdf.format(d);//格式化日期

2.数据状态
	2.1常量
		字面值常量(整数,小数,布尔值true,false,字符,字符串,)
		自定义常量(final修饰的变量)
	2.2变量

	null状态,undefined

3.关键字,标识符,命名法,修饰符

4.线程
Exception: InterruptedException
		   ConcurrentModificationException
		   
		 
		   
实现多线程的方式:
1. 继承Thread类
2. 实现Runable接口
3. 实现Callable接口通过FutureTask包装器来创建Thread线程
4. 使用ExecutorService、Callable、Future实现有返回结果的多线程。


通过 Callable 和 FutureTask 创建线程
1. 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值(返回值为泛型)。
2. 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。
3. 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。
4. 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。



	线程通信:不同种类的线程对于同一个资源的操作
	多线程:
	同步,异步
	死锁
	线程池:


5.异常

6.IO

7.sql
{
	一.添加约束
在字段定义完毕后直接添加 constraint student_id_pk primary key
在所有字段定义完毕后添加constraint student_sex_ck check (sex in('f','m'))

为表格(service)的字段accountid添加外键约束(account 的字段accountID)方法:
 A.直接在定义字段后添加 REFERENCES account(accountid)
 B.在表所有字段定义结束后添加 FOREIGN KEY(accountid) REFERENCES account(accountid)
 C.在表创建后执行如下命令：ALTER TABLE service ADD FOREIGN KEY(accountid) REFERENCES account(accountid)

PreparedStatement 设置字段属性的时候自动进行数据类型匹配检查
Statement执行sql语句的时候是直接传入一个字符串的，不存在对传入数据类型的检查
PreparedStatement void setObject(int index,Object o);
PreparedStatement void setInt(int index,int i);


create trigger tr_stu_sex before insert on stu for each row begin if new.sex not in ('M','F') then insert into stu(id) values(1);

select name from stu ,(select a.sid  sid from (select score,sid from score where cid=1)a,(select score ,sid from score where cid=2)b where a.sid=b.sid and a.score>b.score) r where stu.sid=r.sid

连接池:
dbcp: new BasicDataSource();
c3p0: new ComboPoolDataSource();

Statement
PreparedStatement
CallableStatement(继承于PreparedStatement)
String callSql="{call sp_name(?,?,?)}";

Types存了数据库字段数据类型与java数据类型的对应

数据库SQL:  ojdbc
连接池需要导入两个外包(dbcp)


Oracle:
driver=oracle.jdbc.driver.OracleDriver  
url=jdbc:oracle:thin:@IntAddress:port:sid  
	jdbc:oracle:thin:@(DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=zishan
//两种连接模式：thin模式(不需要oracle客户端)和oci模式(需要oracle客户端)
user=
pwd=
日期的默认格式:  
1:  "27 11月 1992"  | "27-11月-1992"     (中文环境下)
2:	"27 Feb 1992"   | "27-Feb-1992 "     (英文环境下)


MySql
driver=com.mysql.jdbc.Driver
url=jdbc:mysql://IntAddress:port/sid
user=
pwd=

日期的默认格式:  
1: "19921127"     (不能空格)
2:"1992-11-27 "       
MySql没有序列(Sequence),利用  to_increment  自动生成主键 (必须与主键配合使用,且只能增不能减,每次只能自增1) 
alter table emp modify  empno int auto_increment primary key
insert into emp (ename,job,sal)values("张三","工人",4000)     --不用写出empno号
insert into emp values(null,'haha','haha',1234,"1992-11-27",234,null,20)   --全部数据写入的话empno需要写入null让系统自动生成

 oracle默认null为最大值,mySql默认null为最小值
 
 mysql:
 select * from emp order  by mgr desc limit m;  --扫描表内符合条件的(<=m)条记录并取出（有可能符合条件的记录不足m条）
 select * from emp order  by mgr desc limit m,n;--扫描表内(m+n)条符合条件的记录，并取出最后n条记录
 
 
}
8.jdbc


9.反射
reflect

Class 类
Constructor
Method
Field

Annotation 



动态代理:
jdk中动态代理的实现依赖于一个实体工具类Proxy以及一个InvocationHandler接口



10.Servlet
{
	
	jsp：
	SimpleTagSupport
	
	HttpServlet.service();  //无论哪种请求方式,都是经过该方法分发到具体的doGet()方法
	
Get请求头:  request.getHeader()
host : localhost:8080
connection : keep-alive
user-agent : Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.108 Safari/537.36
accept : */*
referer : http://localhost:8080/mytest/test.do
accept-encoding : gzip, deflate, br
accept-language : zh-CN,zh;q=0.9
	
	
	
post请求头:(content,content-length,content-type)
content-type : application/x-www-form-urlencoded
content-type : text/plain;charset=UTF-8 (post请求默认的)


host : localhost:8080
connection : keep-alive
content-length : 0
origin : http://localhost:8080
user-agent : Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.108 Safari/537.36
content-type : text/plain;charset=UTF-8
accept : */*
referer : http://localhost:8080/mytest/test.do
accept-encoding : gzip, deflate, br
accept-language : zh-CN,zh;q=0.9

$.ajax({
          type: type,
          timeout: 10000, // 超时时间 10 秒
          headers: {
              'Access-Token':$.cookie('access_token')
          },
          url: url,
          data: data,
          success: function(data) {
          },
          error: function(err) {
          },
          complete: function(XMLHttpRequest, status) { //请求完成后最终执行参数　
          }
      });	

js获取cookie
document.cookie;//返回一个cookie字符串
var cookieArray=document.cookie.split(";");//把cookie字符串分割成cookie字符串数组	  
	
cookie大小有限制(4k),数量有限制,只能存字符串,可以被用户禁止
Servlet默认设置cookie的有效时长为-1,保存在内存中
禁用session,使用url重写来提交sessionid http://localhost:8080/test/some;jsessionid=4E113CB3(在url后面加上分号)
生成链接地址和表单提交时，使用如下代码：
<a href=”<%=response.encodeURL(String url)>”>链接地址</a>
如果是重定向，使用如下代码代替response.sendRedirect()
response.encodeRedirectURL(String url);


get方式提交数据,是可见的,有大小限制(2k),使用路径直接传递参数
浏览器第一次访问服务器,服务器为期创建一个session对象,里面储存了sessionID,响应时将这个
sessionid保存在response对象里面.浏览器收到的响应头数据中set-cookie里面存的就是sessionid的信息

立刻删除Session对象 void Session.invalidate();
session的有效时间在Server(Tomcat)的web.xml文件中配置(默认缺省时间为30分钟)
 <session-config>
        <session-timeout>30</session-timeout>
  </session-config>

服务器的时间和时区设置可能影响Cookie，IE而言，Cookie的有效时间段是理解为客户端的时间与服务器端时间的间隔，对于FireFox而言，Cookie的有效时间完全由服务器端的时间决定

//jackson-API解析(对象转换为json字符串,将json字符串转换成对象)
response.setContentType(String type); //  text/html | image/png  application/json
ObjectMapper mapper=new ObjectMapper();
String json=mapper.writerValueAsString(Object);


//gjson(谷歌出品的json工具)
Gson tool=new Gson();
String json=tool.toJson(Object o);


//fastjson(阿里巴巴出品的解析json工具)

摘要加密
//不适合数据加密传输
摘要加密的特点：不适用密钥，使用摘要加密算法对明文进行加密之后会得到密文，无法反推出明文。唯一性：不同的明文有不同的密文。不可逆性：即使知道了摘要加密算法，也无法反推出明文。
1.4.2. 如何实现摘要加密
public class MD5Util{
    private static void test1() throws NoSuchAlgorithmException{
        String str = "I love you";
        MessageDigest md = MessageDigest.getInstance("md5");
        //依据指定的加密算法进行加密
        byte[] buf = md.digest(str.getBytes());
        //因为字节数组不方便使用，所以，将其转换成一个字符串
        //BASE64Encoder的encode方法可以将任意的一个字节数组转换成一个字符串
        BASE64Encoder  base = new BASE64Encoder();
        String str2 = base.encode(buf);
        System.out.println(str2);
}
    public static String encrypt(String  origStr){
        MessageDigest md = MessageDigest.getInstance("md5");
        byte[] buf = md.digest(str.getBytes());
        BASE64Encoder  base = new BASE64Encoder();
        String str = base.encode(buf);
        return str;
    }
}
}

11.html
{
<form>标记中有如下常用属性。
Action:用于确定表单的提交目的地址
Method:用于指定表单数据的提交方式，常用有get/post/(put,delete)
Enctype:用于指定表单数据的编码类型。



escape(str);//对字符串进行编码


}



子类创建对象默认会访问父类的无参构造方法,但并没有创建父类的对象（创建对象需要用到关键字 new ）
new Foo()  和Foo()的区别,new表示创建了对象,在内存开辟了空间,Foo()仅仅表示调用构造方法,把成员变量初始化后赋值给子类对象

{一个类中若没有声明其构造方法,则编译器默认会自动为其添加一个public修饰的无参构造方法,很多框架可以调用该无参构造方法创建对象}
spring框架创建对象时会通过反射机制暴力调用构造器或者静态工厂方法(无视权限)


多态,解耦(传入最大的接口,方便后续代码的维护,传入的实体对象实现类有可能以后需要修改)






class文件的装载:
1.加载.class文件进内存
2.连接 检查内部结构,为静态成员分配空间,设置默认初始值,符号引用替换为直接引用
3.初始化 



类加载进方法区:
首先执行静态变量(先默认初始化,然后进行自定义的显示初始化(如果有的话))和静态代码块(平级关系,按书写的先后顺序执行) 
静态变量的默认初始化和静态代码块的执行不论他们在文件中的顺序
static int x(=0;);static {} 
然后再执行构造代码块和成员变量
最后在执行构造方法
1.static {静态变量,静态代码块(在class文件进方法区后执行且只执行一次)}
2.{成员变量,(构造)代码块(每次创建对象时调用)}
3.(public) Class_Name(){构造方法(每次创建对象之后调用)}
 
new Zi(); //创建子类对象,首先加载父类,访问其构造方法super();
Foo.static代码块
Zi静态代码块
Foo构造代码块
Foo构造方法
Zi构造代码块
Zi()构造方法

首先加载父类和子类的全部static代码块

抽象类实现了某个接口,该接口的方法可以在抽象类中不写,默认存在该抽象方法
 

(二进制数)  				正数       负数
计算机显示:		原码				
过渡值:			反码		不变	原码的1变0,0变1,最高符号位的1不变
计算机识别值:		补码		不变	反码数值加1,最高符号位的1不变
进行逻辑运算(&,|)时,0相当于false,1相当于true
位异运算符(^),一个数与另一个数连续位异两次,其值不变  
eg:  a=a^b;
	 b=a^b;  //a^b^b=a;
	 a=a^b;	//a^b^a=b;
<<,>>,>>>

 
查看本机IP地址:
linux    ifconfig
windows  ipconfig     
查看端口:netstat -ano  (中间'-'前面有空格)

html
特殊实体符号:  &emsp(大空格)    &nbsp  &lt &gt  
<pre>
pre 元素可定义预格式化的文本。被包围在 pre 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。
标签的一个常见应用就是用来表示计算机的源代码。
</pre>
<hr/>定义水平线



Servlet
http://IntAddress:port/app-name/url-pattern
302:重定向      
 void javax.servlet.http.HttpServletResponse.sendRedirect(String path) throws IOException
错误:
404:(服务器找不到地址) 
项目没有部署 自定义Servlet对象书写不规范或者没有在web.xml配置文件书写或者书写不正确   网络路径写错


HttpServlet.getServletContext()==GenericServlet.getServletContext()
==GenericServlet.getServletConfig().getServletContext()
ServletContext接口的数据是所有网站自定义Servlet对象共享的
  getServletContext()     getAttribute(String para-name)    setAttribute(String para-name,object para-value)
  
  获取配置文件的参数: Object.getInitParameter(String name);
  
其中,setAttribute(String para-name,object para-value)方法中如果传入数字并且自增,需要用setAttribute("count",++count),
如果用setAttribute("count",count++),这不发生自增(值不变)  每次获取到的值为0  (只对count有效)


ServletContext 定义属性的方法:
1.在servlet类当中获取     getServletContext().setAttribute(String para-name,object para-value);
2.在web.xml配置文件中直接书写
<context-para>
<param-name></param-name>
<param-value></param-value>
</context-para>

Servlet类加载的优先顺序在
<servlet>
<load-on-startup>1</load-on-startup>
</servlet>
数值必须大于等于1,如有相同优先级的,则按xml先后顺序加载,如果是其他数字或者字符串,则不能识别,只能在第一次访问时加载


XML解析方式
1. SAX解析方式
SAX（simple API for XML）是一种XML解析的替代方法。相比于DOM，SAX是一种速度更快，更有效的方法。
它逐行扫描文档，一边扫描一边解析。而且相比于DOM，SAX可以在解析文档的任意时刻停止解析。 
优点： 解析可以立即开始，速度快，没有内存压力
缺点： 不能对节点做修改  ????
2. DOM解析方式
DOM：(Document Object Model, 即文档对象模型) 是 W3C 组织推荐的处理 XML 的一种方式。DOM解析器
在解析XML文档时，会把文档中的所有元素，按照其出现的层次关系，解析成一个个Node对象(节点)。
优点:把xml文件在内存中构造树形结构，可以遍历和修改节点
缺点： 如果文件比较大，内存有压力，解析的时间会比较长


jQuery

$(":button:eq(0)").attr("value","+")
obj.remove();  obj.remove(SELECTOR);
obj.empty();
e.stopPropagation();
e.target;//DOM对象
e.pageX
e.pageY

$("#id_value").subling

回调函数
animate




Servelet  SpringMVC  Struts

静态网页:维基百科,百度百科,小说,新闻,开发手册网页
服务器保存一份HTML文件,响应请求时直接发送该文件

********
动态网页:显示内容因人而异
ObjcetInputStream  ObjectOutputStream 
transient  
服务器保存一个对象,由该对象动态拼成一个网页,发送给浏览器
在java中该对象是 Servelet

Servelet: 满足(SUN|Oracle)规范的对象是组件
储存在服务器上,可以动态的拼接资源(HTML,IMG).  处理HTTP协议

Servelet: SUN推出的用来在服务器端处理HTTP协议的组件(动态网页)


服务器:  本质是一个软件:可以运行Java(WEB)项目的软件运行环境(JAVAEE)
-Tomcat(Apache)
-JBoss
-WebLogic
-WebSphere

Tomcat:本质是软件,可以直接运行使用
1.单独使用(很麻烦):在软件上线的时候在独立运行
2.通过Eclipse管理***

Apache 是 PHP 程序运行的服务器，IIS 是.net 程序运行的服务器

Servlet:  
Tomcat: 加权限:  chmod +x *sh
sh shutdown.sh


URIEncoding="UTF-8"
Cookie URLEncdoer.encode("张三","utf-8");  URLDecoder.decode("张三","utf-8");
1.创建一个Maven项目, war类型打包封装
2.generat deployment(部署web.xml文件)
3.properties target apache(引入javaee的jar外包)
4.new class extends HttpServlet
5.@override
protected void Service(ServletRequest req,ServletResponse rep)throws ServletException,IOException{}

Tomcat服务器本身并不能调用私有构造方法创建对象
	
void Servlet.init(){}  方法,用来接收Tomcat容器传递过来的ServletConfig对象
里面储存了初始化信息(init-param标签内param-name value值)
http协议,还有别的协议比如ajp
Servlet接口:负责服务器与Java代码通信的规则
GenericServlet类:一般的Servlet类
HttpServlet类:专门处理http协议的servlet类
service方法:负责管理请求方式并分别处理的(service是请求的中转站(转交业务给doPost方法和doGet),当然本身也可以直接处理业务)
String method=req.getMethod();
		if(method.equals("Get")){
			doGet(req,rep);
		}
		else{
			doPost(req,rep);
		}
全局属性:项目内全部Servlet对象公共属性ServletContext 被封装进request对象自动传入service(request,response)方法内	
<context-param>
  <param-name></param-name>
  <param-value></param-value>
 </context-param>

配置Servlet对象
<servlet>
  <servlet-name>html</servlet-name>
  <servlet-class>web.HTMLService</servlet-class>
  Servlet类私有属性:ServletConfig  servlet对象初始化后调用Servlet.init(ServletConfig config){}方法传入
  <init-param>
	<param-name></param-name>
	<param-value></param-value>
  </init-param>
  <load-on-startup></load-on-startup>
</servlet>
<servlet-mapping>
  <servlet-name>html</servlet-name>
  <url-pattern>/html</url-pattern>
</servlet-mapping>
异常处理页面
<error-page>
	<exception-type></exception-type>  java异常类型   ||  <error-code>404</error-code>  //网页错误代码
  	
  	<!-- 转发的路径前缀一定是在该项目之内的 (错误页面必须写绝对路径,并且省略项目名(tomcat自动加的项目名))-->
  <location>/WEB-INF/error.jsp</location>
</error-page>
request的getReader()方法和getInputStream()方法
直接采用req.getReader()方法和 req.getInputStream()方法得到的数据不能正常显示(编码表没问题)
1>不显示数据(只能读取post方法提交的数据),而且读取完毕之后就没有数据了,不能复读
JSTL
<c:if test="判断条件">执行语句</c:if>
<c:choose >
<c:when test="判断条件">执行语句</c:when>
<c:when test="判断条件">执行语句</c:when>
<c:when test="判断条件">执行语句</c:when>
<c:
</c:choose>
<c:otherwise >执行语句</c:otherwise>

WEB-INF文件夹下的资源不能被浏览器直接通过路径访问到,起到对重要数据的保护作用
ServletConfig接口的是实现类对象在自定义的Servlet类创建唯一对象的时候由Tomcat自动创建,并在Servlet
调用init(ServletConfig condfig){}时自动传入并被Servlet类对象保存,然后这个
form表单的提交方式:
1.<input type="submit" />
2.超链接js绑定提交事件<a href="javascript:document.form[0].submit();">超链接名字</a>
	如果表单提交需要先通过函数验证数据,则需要改为onsubmit();
server.xml
URIEncoding='utf-8'



地址错误（拼写不正确，字母大小写错误）。
web.xml文件中的<servlet-name>不一致。
工程没有部署。
Web应用程序部署结构没有遵守Servlet规范。
service方法名称写错。
service方法参数类型与标准不一致。
service方法异常、返回值类型与标准不一致。
Servlet类没有继承HttpServlet或实现Servlet接口
web.xml文件中的<servlet-class>写错
service方法中的代码运行时抛出异常


Cookie的有效路径指的是产生该Cookie对象的网络路径及全部该路径以下的子路径(默认情况下)
Cookie的有效路径可以通过setPath(String path)重新定义

(
Integer i=1;
int i1=1;
System.out.println(i==i1);  //编译不报错结果为true
)

(
    int a=9;
		int b=11;
		boolean flag=a++>b--&&b++>a--; 
		//false  逻辑短路,后面不执行
		    System.out.println(flag+",a="+a+",b="+b);
		    //false  a=10,b=10   先进行判断,在自增自减
)

(
long l = 999999;  //编译不报错,数值在int范围内,自动转换为long

)

 //线程安全的类:Vector,Hashtable,BlockingQueue

truncate table t_name  --删除表格的全部数据不删表格,不可回退


Servlet{
请求方式:请求方式不同,服务器处理请求时采用的缓存也不同,提高响应速度
在HttpServlet中,service方法默认会根据请求方式不同而调用不同的doXXX方法
GET
POST
HEAD
PUT
DELETE
OPTION
TRACE

JSP9大内置对象
1.page
2.request
3.session (HttpSession)
4.application (ServeltContext)
5.config
6.pageContext(存取其他的内置对象,本身不能存储数据)本身是抽象类
7.response
8.out 
9.exception (ServletException,IOException)

Servelet(Jsp)中可以保存数据的三个不同的作用域(必须要有setAttribute(String,Object)):
1.request
2.session
3.context


cookie的值只能是ASCII字符，中文需要转换成ASCII码形式，使用URLEncoder.encode()方法和URLDecoder.decode()方法实现
cookie和session是为了解决多个request或者多个servlet类之间传递信息的问题:http协议是一个无状态协议,即服务器默认不会记住浏览器.
cookie和session是用来进行状态管理的
什么是状态? 状态就是浏览器访问服务器的证据(数据)
//浏览器首次访问服务器时,服务器(Tomcat)会自动给访问的浏览器创建一个session对象,并将session对象的SessioinID自动添加到response对象上发送给浏览器,此时会被监听器监听
servlet可以通过
request.getSession()方法来获取session对象的数据(JSESSIONID)
	javax.servlet.http.HttpSession session=req.getSession();
		//session是jsp9个内置对象之一,可以存储任意类型的数据(Object,需要转型)
		session.setAttribute("user", user);
		
		//服务器做出响应时,会自动创建Cookie对象,传入sessionID,设置路径为全局路径,并传给response对象一起发送给浏览器
	/*	Cookie c=new Cookie("JSESSIONID",session.getId());
		  c.setPath("/jsp5");
		  rep.addCookie(c);*/

session缺省时间设置:
1.web.xml配置文件  
<session-config>
	<!-- 这里的数字代表的是分钟 默认设置是30分钟-->
	<session-timeout>1</session-timeout>
</session-config>
2.servlet类当中单独设置
void Session.setMaxInactiveInterval(int seconds)	
URL重写:浏览器禁用cookie,服务器通过URL重写发送SESSIONID


监听器:
监听session,request,context对象的创建和销毁
监听session,request,context对象属性的更改(创建,移除,设置)


第一次请求net不会有记录?


如何生成验证码:
<img src='/createImg.do' title='点击更换' alt='验证码' onclick='this.setAttribute('src','createImg.do?num='+Math.random())'>
'createImg.do?num='+Math.random()这里是生成不同的请求
rep.setContentType("image/png");
		OutputStream os=rep.getOutputStream();
		ImageIO.write(image, "png", os);

公共业务:很多请求都需要进行处理的业务(登入检查,日志)
Servelet:处理请求
Filter:处理公共业务
一般为了降低耦合度
多个过滤器联用,按照web.xml配置文件中<filter-mapping>出现的先后顺序依次过滤
		
}

WEBbasic{
DOM对象:针对(html结构的)CRUD操作
(Document(8),Node(所有的对象都可以都是Node对象(包括元素标签,元素属性,元素文本,)),ElementNode(1),AttributeNode(2),TextNode(3),CommentNode(9),NodeList)
1.C  document.createElement();
		
2.R  document.getElementById("");
	 document.getElementsByTagName("");//通过标签名获取元素
	 document.getElementsByName("");//通过name属性获取元素        
	 document.getElementsByClassName("");//通过class属性获取元素  $('.className')
3.U 

4.D  
$('selector').remove();

创建函数的三种方法:
1:var f=new Function("a","b","return a-b;");
2:function f(a,b){return a-b;}  定义一个名字为f的方法
var f=function(a,b){return a-b;}  匿名函数
3.匿名函数  new function("a","b"){return a-b;}  不能用变量接收

创建一个Option对象var o=new Option("aa", 18);  //第一个变量表示下拉选的选项文本值为"a",value属性为18
向id="select"的元素上增加子元素option方法:
document.getElementById("select").add(o);
document.getElementById("select").appendChild(o);

html 页面上有一个 id 值为 s1 的 <select> 元素，现需要使用 JavaScript 代码清空其所有选项，
下列选项中，错误的是（B）。(options是元素的特殊属性,不可以被直接设为null状态.该属性是一个数组，可以通过设置数组的长度为0来清除数组中的元素，但是，不能试图去掉该属性。)
 A.document.getElementById("s1").options.length = 0;
 B.document.getElementById("s1").options = null;
 C.while (document.getElementById("s1").options.length > 0) {
		document.getElementById("s1").remove(0);
    }
 D.var selObj = document.getElementById("s1");
   while (selObj.childNodes.length > 0) {
             selObj.removeChild(selObj.lastChild);
   }

location.href=""  //保留浏览历史
location.replace=""  //不会保留浏览历史
history.go(x)  //只能前往已访问的地址  x可以为数字(正整数表示前进,负整数表示后退,url字符串直接前往该地址(如果访问过))

WEB{
html网页中如果多个元素设置同value值的id属性,css中id选择器会全部获取这些元素,js中的id获得器则根据上下文顺序只会获取第一个元素
HTTP三点注意事项：
1.HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
2.HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。
3.HTTP是无状态(所以需要session和cookie来记住状态)：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。



<br />换行标签
<hr />加一根水平线
JS(内置大量对象,无需编译,由浏览器引擎(内核)逐行执行):
1.客户端的数据运算
2.客户端表单数据验证
3.浏览器事件触发
4.网页特殊效果制作
5.服务器异步数据提交(ajax)

js可以直接在事件定义时,也可以嵌入html文件中<script>,最好是引用js文件<script src="../.js">

js是解释性代码,代码错误,页面将没有效果

js事件:
1.鼠标事件
2.键盘事件
3.窗口事件
onabort	图像加载被中断	1	3	4
onblur	元素失去焦点	1	2	3
onchange	用户改变域的内容	1	2	3
onclick	鼠标点击某个对象	1	2	3
ondblclick	鼠标双击某个对象	1	4	4
onerror	当加载文档或图像时发生某个错误	1	3	4
onfocus	元素获得焦点	1	2	3
onkeydown	某个键盘的键被按下	1	4	3
onkeypress	某个键盘的键被按下或按住	1	4	3
onkeyup	某个键盘的键被松开	1	4	3
onload	某个页面或图像被完成加载	1	2	3
onmousedown	某个鼠标按键被按下	1	4	4
onmousemove	鼠标被移动	1	6	3
onmouseout	鼠标从某元素移开	1	4	4
onmouseover	鼠标被移到某元素之上	1	2	3
onmouseup	某个鼠标按键被松开	1	4	4
onreset	重置按钮被点击	1	3	4
onresize	窗口或框架被调整尺寸	1	4	4
onselect	文本被选定	1	2	3
onsubmit	提交按钮被点击	1	2	3
onunload	用户退出页面	1	2	3

事件冒泡:子节点的事件出来完毕后会依次向上抛给父节点的事件函数处理;可以取消事件冒泡
e.stopPropagation();  //e表示事件对象


js事件函数:
bind(type, [data], fn)   //绑定事件函数   $obj.bind('click',function(){});可简写成$obj.click(function(e){}); 可以向点击函数传入参数e,表示事件对象event,e.target表示事件源,e.pageX,e.pageY表示点击的坐标
one(type, [data], fn) 
trigger(type, [data]) 
triggerHandler(type, [data]) 
unbind([type], [data]) 

jQuery对象函数:
$obj.hide();
$obj.empty();

读写节点
$obj.html();
$obj.text();
$obj.val(); //读取value属性值
$obj.attr(key); //读取key属性值  



$obj.next();      //下一个元素
$obj.sibilings();//之前的兄弟元素



infinity


js五种基本类型(原始类型primitive )：  typeof var
String boolean number null undefined (null和undefined是特殊的数据类型)
还有2种复合数据类型:function和object (Array,Map,Set(IE不支持Set)) 

js对象

Date
表格:
单元格边距(表格填充)
(cellpadding) -- 代表单元格外面的一个距离,用于隔开单元格与单元格空间单； 元格间距(表格间距)
(cellspacing) -- 代表表格边框与单元格补白的距离,也是单元格补白之间的距离。 
<input type="button" value="按钮" onclick="f1();" />
等价于<button onclick="f1();">按钮</button>

原生ajax请求
var xmlhttp;
	if (window.XMLHttpRequest)
	{
		//  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码
		xmlhttp=new XMLHttpRequest();
	}
	else
	{
		// IE6, IE5 浏览器执行代码
		xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
	}
	xmlhttp.onreadystatechange=function()  //回调函数
	{
		if (xmlhttp.readyState==4 && xmlhttp.status==200)
		{
			document.getElementById("myDiv").innerHTML=xmlhttp.responseText;
		}
	}
	xmlhttp.open(type:"GET",url:"/try/ajax/ajax_info.txt",asyn:true);   //open() 方法用来初始化 HTTP 请求参数,但是并不发送请求。
	//xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded"); //post请求需要自己设置请求头
	xmlhttp.send(null);  //get请求最好直接传null,参数放在url路径上,也可以直接不传参数,但兼容性不好
						//post请求在这里传递参数,格式是string字符串,按照key=value&key=value的格式传递
$.ajax({ url:'findById',  type:'GET',  data:{'id':$('#cb1').val()}, dataType:'json', success:function(data,statusText){  }, error:function(xhr,e1,e2){ } });

}

}



Spring{
扫描包内(包括子包)所有包含注解Component的类并添加到spring框架管理
<context:component-scan base-package=""/>
<mvc:annotation-driven/> MVC的相关注解比如@RequestParam才生效



所有的对象都可以被设为bean元素,比如class,集合<util:list id="">.
创建对象的方式(反射机制强行创建对象(无视权限))
	1.无参构造<bean id="" class=""/>  (name属性废弃不用了,class必须是带包名的class文件路径)
	2.静态工厂方法(必须有static修饰,否则报错)创建对象<bean class="" factory-method=""/>
	3.实例工厂方法<bean factory-bean="bean_id"  factory-method=""/>

scope="singleton"(默认)  |"prototype" (原型)

lazy-init="false" (默认) |"true" 
	
配置文件<bean>标签属性
<bean  id="date(唯一约束)"  class="java.util.Date(带包名的类路径名)" scope="singleton(不写默认,单例模式,)| prototype() "
	lazy-init="true(默认为false,单例模式下自动创建对象)"	init-method="初始化自动调用的方法名"  destroy-method="方法名 容器关闭前调用此方法销毁对象(只在单例模式下有效)"
    />
描述Spring框架的作用和优点。
Spring框架的作用和优点如下：
1. Spring是一个开源的轻量级的应用开发框架，其目的是用于简化企业级应用程序开发，减少侵入；
2. Spring提供的IoC和AOP应用，可以将组件的耦合度降至最低，即解耦，便于系统日后的维护和升级；
3. Spring为系统提供了一个整体的解决方案，开发者可以利用它本身提供的功能外，也可以与第三方框架和技术整合应用，可以自由选择采用哪种技术进行开发。


静态工厂方法创建对象factory-method=""(该方法必须是static修饰的,否则就没有意义)

scope="singleton"|"prototype"|"session"|"request"|"global Session"

lazy-init属性对原型无效(scope="prototype")
destroy-method属性只对单例(singleton)有效

init-method属性对原型有效,在创建对象时自动调用

set方法注入(最常用),class中setXxxx(Object o)方法必须是public修饰的
构造器注入,无视构造方法的访问权限
autowise:自动装配 表示容器自动建立对象之间的依赖关系 byName:依据属性名(bean id)查找相应的bean( 以属性名作为bean的ID来查找,找到之后调用set方法来建立依赖关系) 
		最终还是采用set方法 tips:如果找不到则不注入 byType:依据属性的类型来查找相应的bean,找到之后,调用set方法
		通过类型查找到两个或两个以上的bean则会不报错,特别是存在继承,实现关系的父子类上,同时符合父类 -->
		<!-- constructor:与byType类似,通过类型查找匹配的bean对象,在多态环境下容易发生异常(匹配到多个合适的bean)只不过调用构造器来注入 -->
		<!-- 默认不注入 -->

autowire="no"(默认)|"byName"|"byType"|"constructor"|"autodetect"

<util:properties location="classpath:config.properties">


组件扫描
<context:component-scan base-package="包名"/>

<mvc:annotation-driven/>
<bean id='' class="" scope="" lazy-init=""    autowire="byName"  init-method="" destroy-method="">
@Component("")      @Scope("")     @Lazy("")  @Autowired  --@Qualifier("id") 
@Postconstruct    @PreDestroy

spring框架可以自动向处理器的处理方法传入request,session,和ModelMap对象


}





{
数据库SQL对于空字符串与null的情况返回的结果都是空的集合

向数据库传入空字符串,该字段结果为空,不为null;
	
JAVA空指针与空字符串的问题:
Integer.parseInt(null);//异常
Integer.parseInt("");//异常
System.out.println("".equals(null));  //false
//System.out.println(null.equals(""));  //编译错误  运行时空指针异常
System.out.println("xxx".equals(null));//false
System.out.println("xxx".equals(""));//false

		public User findByName(String name, String pwd)
			throws UserNotFoundException, PasswordNotCorrectEception {
		//判断空指针与空字符串的情况
		if(pwd==null||pwd.trim().isEmpty()) throw new PasswordNotCorrectEception("密码不能为空");
		User user=userDao.findByName(name);
		if(user==null) throw new UserNotFoundException("用户名错误");
		if(!user.getPassword().equals(pwd))throw new PasswordNotCorrectEception("密码错误");
		return user;
	}
	
	
	

}


反射{
1.Class c=Class_Name.calss;//使用泛型明确class类型(不会初始化)
2.Class c=Object.getClass();//同过实例对象获取class对象
3.Class c=Class.forName(String path);//通过class文件的路径获取class文件对象

Constructor Class.getDeclaredConstructors()
反射可以获取从父类继承,以及自己的全部公开的方法;
反射可以获取自己的全部方法(包括private,但是不能获取父类继承的方法);
未被重写的方法,实际上是去加载父类并调用父类的方法,需要考虑访问权限的问题.

protected Object Object.clone();
不重写该方法:只能在子类的成员方法中通过super关键字调用,(前提:在本类中)或者通过该子类对象的引用去调用



}


匿名内部类; 
 * 适合创建那种只使用一次的类，创建匿名内部类时会创建该类的实例，类定义立即消失，匿名内部类不能重复使用 
 * 必须继承一个父类或者实现一个接口，但是只能继承一个父类或者实现一个接口 
 * 还有2点注意 
 * 第一  匿名内部类不能是抽象类，因为抽象类不是实例化，而内部类要创建类的实例 
 * 第二  不能定义构造器，因为没有类名，但是可以定义实例初始化 
 *  
内部类可以另外继承或实现其他的类或接口
//(引用类型)强转编译不报错,运行时刻可能报错(子类引用指向父类对象运行抛出异常)
//子类可以拥有与父类同名的变量
//Fu f=new Zi();  等同于  Fu f=new Fu();  Zi z=new Zi();  f=z;(无需强转)
public class Zi extends Fu{
int i=3;
	public static void main(String[] args) {
		Fu f=new Zi();
		System.out.println(f.i);  //输出父类的变量i=1
		Zi z=new Zi();
		f=z;  //向上造型
	}
}
class Fu{
	int i=1;
	
}

{
	class Pet{
	 int x=0;}
	class Cat extends Pet{
	int x=0;  //子类可以拥有与父类同名的变量
Pet c= new Pet();
Cat p=  (Cat)c;}   //子类引用指向父类对象编译不报错,运行异常(强转)
}

//子类接口可以写出父类接口的同名抽象方法;而子接口的实现类只需实现一个方法即可
//子类接口的方法可以重载父类接口方法
interface Fu{
	void say();
}
interface Zi extends Fu{
	void say();
}
class x implements Zi{
	@Override
	public void say() {
	}
}

 
 Java中方法绑定有哪些形式？
    A.编译时刻绑定(static ,final,private)
    B.运行时刻绑定
    
    
  表达式"hello" instance of String返回的值是哪项？//true
  
	(List l=new ArrayList();
	l.add(1);
	l.add(2);
	for(Iterator it=l.iterator();it.hasNext();){ 
	//不使用泛型也能强转为Integer list加不加泛型迭代器取出来的都是Object对象
		Integer o=(Integer) it.next();
		System.out.println(o);  
	})
	
	编译时刻绑定的方法: 
	A．静态方法
    B. private方法
    C．final方法
	
关于try...catch...finally结构，描述正确的是哪项？  
		try{}finally{}   //正确
		try{}catch(Exception e){} //正确
		try{}//错误
AJAX{
AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。
AJAX 不是新的编程语言，而是一种使用现有标准的新方法。
AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。
AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。
}

{
在 PHP 中,有两种基本的输出方法:echo 和 print;
echo - 能够输出一个以上的字符串;
print - 只能输出一个字符串,并始终返回 1


Razor 是一种将基于服务器的代码添加到网页中的标记语法;
Razor 具有传统 ASP.NET 标记的功能,但更容易使用并且更容易学习;
Razor 是一种服务器端标记语法,与 ASP 和 PHP 很像;
Razor 支持 C# 和 Visual Basic 编程语言;所以选D
}

MyBatis{
 SqlSessionFactoryBuilder sfb=new SqlSessionFactoryBuilder();
 SqlSessionFactory sf=sfb.build(InputStream config);
 SqlSession ss=sf.openSession();//自带commit();rolllback（）；
 
 DefaultSqlSession(SqlSession接口的实现类)
 DefaultSqlSessionFactory(DefaultSqlSessionFactory接口的实现类)
 
 
 SqlSessionTemplate(实现了SqlSession接口,用户spring框架)
 SqlSessionFactoryBean
 MapperScannerConfigurer
 
 EmpDao dao=ss.getMapper(class<T>);

 @Param("id") String str
 映射文件中主要通过Param中的id来辨别参数
 如果是多个参数且参数的数据类型不一致，那么就不要写parameterType
 如果是多个数据类型相同的参数（数组，链表），paramterType="集合中元素的数据类型"，也可以不写
 
<insert  useGenarateKeys="true" keyProperty="">
 
需要手动关闭SqlSession对象,需要手动提交事务

映射文件
Mapper映射器:符合映射文件要求的接口(Dao类的接口)
SqlSession.getMapper(class<T>);

spring框架集成MyBatis(主要方式)
springjdbc: JdbcTemplate

6个包:spring框架2个包:spring-webmvc,spring-jdbc
	  jdbc连接池2个包:ojdbc,dbcp,
	  MyBatis两个包:mybatis,mybatis-spring

		SqlSessionFactoryBean
			dataSource
			mapperLocations
		MapperScannerConfigurer
			<property name="sqlSessionFactory" ref="sqlsf"/>
			<property name="basePackage" value="dao"/>
			[<property name="annotationClass" value="annotations.MapperAnnotation"/>]


Spring框架集成MyBatis(方式二)
SqlSessionTemplate


}


spring-jdbc{
	JdbcTemplate
	RowMapper
	
	
}


Ajax{
asynchronous javascript and xml
异步的js和xml
异步请求,接受响应时不会刷新页面

getResponseHeader();
getAllResponseHeaders();

json
用来代替xml的轻量级数据传输格式
跨平台(语法借鉴了js),封装数据
解析快

ajax对象属性:
onreadystatechange
readyState(0(请求未初始化),1(已连接服务器),2(请求发送成功),3(请求处理中,正在获取数据),4(获取了所有响应数据))
status(200(请求成功),302,400,404,500)
responseText
responseXML

缓存问题:发送get请求时,有的浏览器(IE)不会在向服务器发送相同的请求(同url),而是直接从缓存中提取数据.  (空内容的post方法会发送)不上传数据的post方式可以不用写请求头
post方式上传数据不设置消息头服务器无法读取数据


编码问题:get:   xhr.open('get',encodeURI(uri),true);
		post:

缓存问题:使用随机数添加URL后缀

<script type="text/javascript">



//1.获取ajax对象
function getXHR(){
var xhr;
//大部分浏览器都是支持的
if(XMLHttpRequest){
xhr=new XMLHttpRequest();
}
//老古董IE不支持
else{
	xhr=new ActiveXObject("MicroSoft.XMLHTTP");
}
return xhr;
}
</script>

//2.创建请求(get方式和post方式)
创建请求方法send(String method,String servletpath,boolean asynchronous)中
第三个参数为true:表示ajax对象发送请求和接受数据后不会销毁当前页面,用户可以操作当前页面
第三个参数为false:表示ajax对象发送请求和接受数据后不会销毁当前页面,但是当前页面被锁定,无法操作

1.get方式
xhr.send("get","url",true);  


//按照协议要求post请求必须带消息头,而ajax对象默认不会添加消息头
//post方法需要手动添加请求头
xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");



发送请求
xhr.send(null);//get方式请求最好加上null,如果什么都不写的话浏览器可能会不兼容

xhr.send("adminCode=亚索&pwd=1234");

网络通信


json
javascript object notation 声明
轻量级的数据交换格式(json借鉴了javascript的部分语法)
比xml空间占用小,读取速度快
数据交换:

java对象----------js对象





jQuery封装ajax对象:
url:
type:
data:
dataType:json字符串  经过JSON.parse(String json)来获取json对象数组
		 text  
		 html
		 xml  (一般用json代替)
		 script  js脚本
success  绑定请求成功的回调函数
		
		//obj表示服务器返回的数据(如果是json字符串,自动转换成json对象
		function (obj){
		}
		
error:  处理错误


$(obj).load("getPrice.do","flight="+flight);

//对象属性的先后顺序无所谓
$.ajax(xhrobj);  //$.ajax(xhrobj)方法
var xhrobj={"url":"  ",};

取特殊的key值比如关键字,数字   if,
list[0]["if"]
list[0]["88"]






//方式一:直接定义ajax对象
$.ajax({"url":"random.do","type":"get","dataType":"text","success":function(data){
		$("#show").val(data);
	}});
	
						method(post/get)
						//{"url":xxx}对象
$.ajax({"url":"check.do","type":"get","data":"adminCode=king"});


//方式二:
					//请求参数
$obj.load(String url[,data]);  //默认会将服务器放回的数据写在obj.innerHTML  input无效 需要使用回调函数 调用val();
$obj(url,data,function(x){});  //这里的x表示的是服务器返回的数据

$getJson(url,data,function(){});


$(selector).load(url,data,callback) 把远程数据加载到被选的元素中 
$.ajax(options) 把远程数据加载到 XMLHttpRequest 对象中 
$.get(url,data,callback,type) 使用 HTTP GET 来加载远程数据 
$.post(url,data,callback,type) 使用 HTTP POST 来加载远程数据 
$.getJSON(url,data,callback) 使用 HTTP GET 来加载远程 JSON 数据 
$.getScript(url,callback) 加载并执行远程的 JavaScript 文件 

(selector) jQuery 元素选择器语法

(url) 被加载的数据的 URL（地址）

(data) 发送到服务器的数据的键/值对象

(callback) 当数据被加载时，所执行的函数

(type) 被返回的数据的类型 (html,xml,json,jasonp,script,text)

(options) 完整 AJAX 请求的所有键/值对选项




Map显示的结构与entity类一样
{key:value}形式

list,数组都是  [{},{}]  ["","",""]

[{"age":5,"name":"Tom","price":4.5},{"age":6,"name":"Som","price":5.5}]

JSON是javascript的一部分
JSON是javascript的对象直接量语法,用于声明js对象
JSON字符串:符合JSON语法的字符串

//创建对象,创建数组

var obj={age:5,name:'TOM'}; //声明对象直接量

var ary=[1,"2",3,true];  //声明数组对象

var str='{"name":"TOM","age":6}';
var str='[{"name":"TOM","age":6},{"name":"SOM","age":7}]';

JSON字符串转换成json对象
//宽松版容易出BUG  直接调用eval(str);方法容易错误
JSON字符串转换成json对象   var str=xhr.responseText;
var jsonObj=JSON.parse(str);  //JSON.parse(String str)的底层是eval()函数

json可以存储对象,数组,字符串


//严谨写法
var obj=eval('('+str+')');  //加双括号



String 
public int compareTo(String anotherString) {
        int len1 = value.length;
        int len2 = anotherString.value.length;
        int lim = Math.min(len1, len2);
        char v1[] = value;
        char v2[] = anotherString.value;

        int k = 0;
        while (k < lim) {
            char c1 = v1[k];
            char c2 = v2[k];
            if (c1 != c2) {
                return c1 - c2;
            }
            k++;
        }
        return len1 - len2;
    }

// 自定义异常:可以继承自Exception或者RuntimeException


存储过程,存储函数,触发器

监听器,过滤器,拦截器



Object.writeValueAsString(Object o);//底层调用了反射机制获取对象属性(包括私有属性和从父类继承的属性)
//只会获取属性,不会获取方法


存储方式:
内存:
外存的文件:
外存的数据库:
外存的数据库:

内存:瞬态,分配对象(数据-对象),
外存:  数据库(管理文件的软件)(硬盘文件) DBMS提供了并发管理,适合多线程访问
写文件是一个线程,读取文件是多个线程
//文件只能单线程访问

数据结构:
数组;链表,哈希表,枚举


mysql  -u用户名 -p密码
mysql  -uroot  -p zzanywn

数据库来管理数据库(存用户名,密码,存储过程等等长久文件数据)
查询数据库  show database//

创建数据库对象: createt database db_name//
drop database db_name//


ENGINE=InnoDB DEFAULT CHARSET=utf8;
set names utf8  	--(mysql不能加'-'  utf8)
source file_path   --执行sql文件里面的命令

{
//apache,junit eclipse自带
	
spring-webmvc
spring-jdbc

mybatis
mybatis-spring

ojdbc || mysql
dbcp  2个包 或者c3p0

jsckson 3个包 或者 gson


<dependencies>
	<dependency>
  		<groupId>jstl</groupId>
  		<artifactId>jstl</artifactId>
  		<version>1.2</version>
  	</dependency>
	
  	<dependency>
  		<groupId>org.springframework</groupId>
  		<artifactId>spring-webmvc</artifactId>
  		<version>3.2.8.RELEASE</version>
  	</dependency>
  	
  	<dependency>
			<groupId>commons-dbcp</groupId>
			<artifactId>commons-dbcp</artifactId>
			<version>1.4</version>
		</dependency>
		
		<dependency>
  	<groupId>org.mybatis</groupId>
  	<artifactId>mybatis</artifactId>
  	<version>3.2.8</version>
  </dependency>
  <dependency>
  	<groupId>org.mybatis</groupId>
  	<artifactId>mybatis-spring</artifactId>
  	<version>1.2.3</version>
  </dependency>
  <dependency>
  	<groupId>org.springframework</groupId>
  	<artifactId>spring-jdbc</artifactId>
  	<version>3.2.8.RELEASE</version>
  </dependency>
  
  <dependency>
  <groupId>mysql</groupId>
  <artifactId>mysql-connector-java</artifactId>
  <version>5.1.6</version>
</dependency>
  
  <!-- jackson3个包 -->
  <dependency>
  		<groupId>com.fasterxml.jackson.core</groupId>
  		<artifactId>jackson-annotations</artifactId>
  		<version>2.2.3</version>
  	</dependency>
  	<dependency>
  		<groupId>com.fasterxml.jackson.core</groupId>
  		<artifactId>jackson-core</artifactId>
  		<version>2.2.3</version>
  	</dependency>
  	<dependency>
  		<groupId>com.fasterxml.jackson.core</groupId>
  		<artifactId>jackson-databind</artifactId>
  		<version>2.2.3</version>
  	</dependency>
  
  </dependencies>

  DigestUtil.md5Hex(String );  //生成MD5密码  (32位字符)
  UUID.randomUUID().toString();//自动生成唯一ID
  
  
    .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar
    bin,jre/bin
	
	
	//返回部分数据,用map封装部分字段
	JSON : list<Map<String,Object>>,List<Object>,Object
	//map取出的属性是无序的LinkedHashMap
}



{
	MyBatis框架对于可能查出多条记录但是返回值只有一个的情况会报异常
	新加入映射文件的(sql)语句必须
	泛化,把子类共有的属性和方法抽象到父类种,把该父类抽象
	
	$obj.on('click','selector',(function(){}));
	
	load是jQuery的异步方法,用来在加载网页
	异步加载网页
	
	window代表浏览器对象
	
	断点测试
	变量的值 变化  (Local内存值变化)
	
	实体类的属性名更应该和前端传进来的属性名相同,方便spring框架获取数据,封装对象
	实体类的属性还应该和数据库的字段名相同,方便查询,否则就要使用别名或者resultMap
	
	


数据结构(集合)
数组
链表()




算法(排序,查找)  
冒泡排序
二分法
快速查找


整数,小数
正数,负数

Integer.toBinaryString(int x);//转换成2进制
只有Integer和Long有解析数字成二进制的算法(方法)

所有底层的计算都是以二进制数的形式进行的,二进制数的补码
原码的
反码
补码


-n=~n+1
一个整数的负数等于该数取反+1


unicode 3.2  ucs char 类型 0~65535
超过的部分直接用int代替
String str=String.format("%010d",int x);


负数的>>操作(实际上是除以2^n):右移多少位就在最前面补多少位1  (小数的话向下取整数)
>>>的操作,无视正负数,最高位全部补0  负数>>>x会得到很大的正数
左移右移的优先级高于&高于|
<<,>>,>>> 高于 &  高于 ^ 高于 | 

float小数
指数,小数
Integer.toBinaryString(Float.floatToIntBits(float));

面向对象:
封装
继承
多态

js里声明的全局变量和方法其实都是window的属性和方法,与document无关

js
创建对象
设置属性
增删改查属性

js对象没有封装性,因为对象的属性可以随意增删
js不是面向对象的语言,只是基于对象;
js 对象的底层实际上是一个散列表,添加对象属性相当于直接put(key,value);
删除属性相当于remove(key);
访问对象属性相当于get(key);
//删除对象属性
delete obj.attr;
//添加对象属性  直接赋值
obj."key"="value";
//访问属性
obj.age
obj.say();//调用方法

<li class="disable">
	<a >
		<i class="fa fa-file-text-o cashNote" title="online" rel="tooltip-bottom"></i> [noteTitle]
		<button type="button" class="btn btn-default btn-xs btn_position btn_delete"><i class="fa fa-times"></i>
		</button>
		<button type="button" class="btn btn-default btn-xs btn_position_2 btn_replay"><i class="fa fa-reply"></i>
		</button>
	</a>
</li>';


//向jsp页面传值问题
1.数据绑定到request对象转发到jsp页面(返回值为String jsp_name)
2.数据绑定到map,封装到ModelAndView对象里发送过去(返回 new ModelAndView(String jsp_name,map))
3.数据绑定到ModelMap  ModelMap.addAttribute(String,Object);//底层还是利用request增加attribute
4.直接使用注解@ModelAttribute(String key)

spring重定向:
1.
public String handle(){
	return  "redirect:xxxxxx";
}
2.
public ModelAndView handle(){
	return new ModelAndView(new RedirectView("xxxx"));

	
	
HTTP 1.0 短连接 ----->HTTP 1.1 长连接
HTTPS 安全机制
过滤器和拦截器都需要单独写入配置文件
拦截器也可以写入注解@Component  组件扫描(不是必须的) 但在注册bean时写成<ref bean=""/>必须写
也可以单独注册,<bean class="lk.note.interceptors.AccessInterceptor"/>不用写注解(不必要)

seesionId 在浏览器都存在cookie

//心跳监测
浏览器加一个脚本,定时发送请求服务器,使session一直保存.


静态执行
动态执行


反射API
动态创建对象
可以创建任何对象

如果没有父类了,Class.getSuperClass()方法返回null

//获取该方法的注解接口对象(返回null说明没有该注解)
Method.getAnnotationByType(Class<T> annotationClass);


反射的应用:
反射需要查找.class文件,耗时,容易出错,性能差
1.Eclipse的快捷键导出public属性和方法(包括父类的)
2.spring框架:bean对象的生成(singleton,调用构造方法(私有构造也行))
	动态加载类
	动态创建bean
	动态注入属性(包括私有属性注入)  (一般调用get,set方法)
	动态解析注解
3.myBatis 
实体类只会调用无参构造方法
获取设置属性优先调用get,set方法,没有才用反射
利用反射获取实体类的属性(没有get方法也行,有get方法直接调用get方法,没有get方法直接利用发射获取属性)
查询的时候,利用反射将查询结果注入实体对象中
创建实体类对象,将查询到的结果调用set方法注入属性



AOP面向切面编程(解耦,在不修改源代码的情况下给程序动态添加统一功能的技术,如日志记录,运行时间,事务管理)
基于性能测试
底层是动态代理(基于反射):动态创建类,动态调用方法
//创建代理对象,调用代理对象的方法




aop.@Before
us.findByName()
aop.@After
aop.@AfterReturning
//没有异常,先执行finally,在执行return


????
aop.@Before
us.findByName()
aop.@After
aop.@AfterThrowing
//有异常,先执行

try{
	@Before
	
	业务层方法
	
	@AfterReturning
	
	
}catch(Throwable t){
	@AfterThrowing
	
}finally{
	@After
}


around.业务方法执行前
aop.@Before
us.findByName()
around.业务方法执行后
业务方法执行后的结果为:User [id=ea09d9b1-ede7-4bd8-b43d-a546680df00b, name=yasuo, password=7908836f4219f9c41500829b164ddd6c, token=null, nick=null]
aop.@After
aop.@AfterThrowing




@Before

@Transactional//需要进行事务处理的
DML
update
delete
insert

@AfterReturning

@AfterThrowing

@After



@Component
@Aspect 
public class Demo1Aspect {

    /**
     * 环绕通知 方法:
     *  1. 必须有返回值值Object
     *  2. 必须有参数  ProceedingJoinPoint
     *  3. 必须抛出异常
     *  4. 需要在方法中调用  jp.proceed()
     *  5. 返回业务方法的返回值
     * @param jp
     * @return 
     * @throws Throwable
     */
    @Around("bean(userService)")
    public Object test5(ProceedingJoinPoint jp)
        throws Throwable{
        Object val = jp.proceed();
        System.out.println("业务结果:"+val);
        throw new UserNotFoundException(
                "就是不让登录");
    }

}
execution(User lk.note.service.UserService.findByName(String,String))
around.业务方法执行前
aop.@Before
us.findByName()
around.业务方法执行后
业务方法执行后的结果为:User [id=ea09d9b1-ede7-4bd8-b43d-a546680df00b, name=yasuo, password=7908836f4219f9c41500829b164ddd6c, token=null, nick=null]
aop.@After
aop.@AfterReturning
JsonResult(Object o)




拦截器可以测试整个请求-响应完成过程的时间
aop可以测试业务层(最耗时的操作)的完成过程时间

$Proxy

代理对象只能一个一个的调用方法,直接通过getMethods();方法获取的方法数组无法直接被proxy对象调用
NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not available [native method]


Object...args如果不传入参数,则args依然存在,只不过长度为0


代理类是公共的、最终的，而不是抽象的。 
未指定代理类的非限定名称。但是，以字符串 "$Proxy" 开头的类名空间应该为代理类保留。 
代理类扩展 java.lang.reflect.Proxy。 
代理类会按同一顺序准确地实现其创建时指定的接口。 
如果代理类实现了非公共接口，那么它将在与该接口相同的包中定义。否则，代理类的包也是未指定的。注意，包密封将不阻止代理类在运行时在特定包中的成功定义，也不会阻止相同类加载器和带有特定签名的包所定义的类。 
由于代理类将实现所有在其创建时指定的接口，所以对其 Class 对象调用 getInterfaces 将返回一个包含相同接口列表的数组（按其创建时指定的顺序），对其 Class 对象调用 getMethods 将返回一个包括这些接口中所有方法的 Method 对象的数组，并且调用 getMethod 将会在代理接口中找到期望的一些方法。 
如果 Proxy.isProxyClass 方法传递代理类（由 Proxy.getProxyClass 返回的类，或由 Proxy.newProxyInstance 返回的对象的类），则该方法返回 true，否则返回 false。 
代理类的 java.security.ProtectionDomain 与由引导类加载器（如 java.lang.Object）加载的系统类相同，原因是代理类的代码由受信任的系统代码生成。此保护域通常被授予 java.security.AllPermission。 
每个代理类都有一个可以带一个参数（接口 InvocationHandler 的实现）的公共构造方法，用于设置代理实例的调用处理程序。并非必须使用反射 API 才能访问公共构造方法，通过调用 Proxy.newInstance 方法（将调用 Proxy.getProxyClass 的操作和调用带有调用处理程序的构造方法结合在一起）也可以创建代理实例。 


violation 违反
moudle 模件

spring模式,框架,技术

声明式事务  ---->  aop   ----->  动态代理  ----->  反射

(事件冒泡)
事务传播
一个业务处理方法的事务传播到另一个业务处理方法的事务
事务的整合

数据库并发操作(读锁/写锁)
隔离级别
serializable（串行化）：可避免 脏读、不可重复读、虚读情况的发生。
repeatable read（可重复读）：可避免 脏读、不可重复读， 不可避免 虚读。mysql采用可重复读。
read committed（读已提交）：可避免 脏读，不可避免 不可重复读、虚读。oracle采用读已提交。
read uncommitted（读未提交）：不可避免 脏读、不可重复读、虚读。


1.串行化(序列化) 最高级别的隔离,效率最低,最安全(每个线程(事务)之间按顺序执行,一个事务结束后另外一个事物才能执行)
2.可以重复读取()
3.读取提交后的数据(修改状态的数据读不到)//默认(并发和安全的平衡选择) 可以同时开启读和写的事务,但只能读取写入操作中提交的数据,可能在一次读的事务中,
4.可以读取修改中(未提交的数据)的数据(脏读)


1.脏读
2.不可复读(update操作,删除)
3.幻读(删除插入操作)


http 1.1
http 2.0
http文件如何下载
html,css,js,media,text,xml,image,json

ByteArrayOutputStream 存在内存的临时性的字节输出流

initator

<image title="鼠标悬浮时显示文字" alt="图片丢失时显示的描述信息" src="直接写请求,发送get请求获取图片"/>


显示图片：直接设置
@RequestMapping(value="",produces="image/png" )

下载图片
@ResponseBody
	//@ResponseBody会自动处理控制返回值,如果是javabean对象,自动把该对象转换成json字符串
	//如果是byte[]数组,则将该数组直接封装进响应的消息body
	//这里的produces="image/png" 相当于 resp.setContentType("image/png");
	@RequestMapping(value="/downImage.do",produces="application/octet-stream")
	public byte[] downloadImg(HttpServletResponse resp) throws IOException{
	//这里必须写名响应头  filename表示下载的文件名字
	resp.setHeader("Content-Disposition", "attachment;filename=\"img.png\"");
		return createImg1();
	}
	
response.setContentType("test/html");
//识别不了的类型,全部按文件下载,文件名为域名

excel文件下载
需要导包poi
<dependency>
  <groupId>org.apache.poi</groupId>
  <artifactId>poi-ooxml</artifactId>
  <version>3.13</version>
</dependency>


工作库,工作表,行和列
//创建Excel文件
	private byte[] createExcel()throws IOException{
//		us.
		//把数据库的数据存入Excel文件
		
		//1.创建工作库(Excel文件)
		HSSFWorkbook workbook=new HSSFWorkbook();
		
		//2.创建工作表
		HSSFSheet sheet=workbook.createSheet("demo");
		
		//3.创建数据行  
		HSSFRow row=sheet.createRow(0);
		
		//4.创建数据列(格子)
		
		HSSFCell cell=row.createCell(0);
		cell.setCellValue("HelloWorld");
		
		//把Excel文件保存为byte数组
		ByteArrayOutputStream out=new 
				ByteArrayOutputStream();
		workbook.write(out);
		
		return out.toByteArray();
	}
	
//接收上传的文件
	@ResponseBody
	@RequestMapping("/upload.do")
//spring利用MutipartFile接收上传的文件 文件中的一切数据 对象的引用名字必须和表单提交文件的name属性值保持一致
public JsonResult upload(MultipartFile userFile1,MultipartFile userFile2) throws IOException{
		System.out.println("/upload.do");
		
		String file1=userFile1.getOriginalFilename();//获取完整的文件名(包括文件类型信息)
		String file2=userFile2.getOriginalFilename();
		System.out.println(file1);
		System.out.println(file2);
	//保存文件到服务器本地
		//1.userFile1.transferTo(目标文件) 可以处理大文件
		//2.userFile1.getBytes();  获取文件的全部数据,将文件全部读取到内存中,适合读取小文件
//		byte[]bs=userFile1.getBytes();
//		bs=userFile1.getBytes();
//		PrintWriter pw=new PrintWriter(new BufferedOutputStream(new FileOutputStream(""),"utf-8"));
		
		//3.userFile1.getInputStream();  获取上传文件的流,适合处理大文件(transferTo的底层就是)
		
		File dir=new File("d:/file");
		dir.mkdir();
		/*userFile1.transferTo(new File(dir,file1));
		userFile2.transferTo(new File(dir,file2));*/
		
		
		BufferedInputStream is=new BufferedInputStream(userFile1.getInputStream());
		BufferedOutputStream bs=new BufferedOutputStream(new FileOutputStream("d:/file"+file1));
		int x=-1;
		while((x=is.read())!=-1){
			
		}
		
		
		
		System.out.println("文件保存完毕");
		return new JsonResult(true);
	}

	
	The current request is not a multipart request
	
	
ea09d9b1-ede7-4bd8-b43d-a546680df00b


List<Map<String, Object>>findNotes(@Param("user")String arg0,@Param("notebookId")String arg1,@Param("statusId")String arg2);

<select id="findNotes" resultType='map'>
select cn_note_id noteId ,cn_note_title as noteTitle from cn_note
<!-- 去除多于的and -->
<trim  suffixOverrides="and" >  <!--prefixOverrides="and"  -->
<where>
<!--这里的test属性值表示的是@Param("name"),#{与前面的name相同} -->
<if test="user!=null">cn_user_id=#{user} and </if>
<if test="notebookId!=null">cn_notebook_id=#{notebookId} and </if>
<if test="statusId!=null">cn_note_status_id=#{statusId} and </if>
</where>
</trim>
order by cn_note_last_modify_time desc
</select>


Mybatis
替换表名,字段名,关键字,用${}绑定

多表关联查询

${} sql语句的拼接 (必须小心使用,有可能造成sql注入)  可以用来传入表名,字段名
#{} PreparedStatement传入参数
所有基本数据类型都用他的包装类

insert into table () values(),(),();//一次插入多条记录


useGenarateKeys="true"


js使用<input type="file" />表单空间直接上传文件
function ajaxUpload(){
	var file1 = $('#file1')[0].files[0];
	var file2 = $('#file2')[0].files[0];
	//创建内存中的表单对象
	var form = new FormData();
	//添加向服务器传输的数据
	form.append('userFile1', file1);
	form.append('userFile2', file2);
	
	$.ajax({
		url:'user/upload.do',
		data: form,
		type: 'POST',
		dataType: 'json',
		contentType: false,
		processData: false, 
		success: function(obj){
			if(obj.state==1){
				$('#result').html("成功!"); 
			}
		}
	});
}

{
	
	// @ResponseBody会自动处理控制返回值,如果是javabean对象,自动把该对象转换成json字符串
	// 如果是byte[]数组,则将该数组直接封装进响应的消息body
	// 这里的produces="image/png" 相当于 response.setContentType("image/png");
	@ResponseBody
	@RequestMapping(value = "/image.do", produces = "image/png")
	
	传入图片:
	1.直接用response.getWriter();输出图片
	
	
	
}



{
反射.动态代理
JDK动态代理只能对接口做动态代理
CGlib是spring框架中更加强大的动态代理Api
1.jdk动态代理技术的实现依赖与InvocationHandler接口和Proxy实体类
2.动态代理需要一个实现InvocationHandler接口的实体类,这个类的实例化需要传入代理对象
3.动态代理对象不要获取全部方法的数组,如此调用会出错
4.Object o=new Instance();
o.getMethod(String methodName,Object...args) 这样调用只能获取引用o中的方法
o.getDeclaredMethod(String methodName,Object...args); 这样调用可以获取引用o指向的实例对象的方法

o.getMethods();可以获取实例对象和引用中的全部公开方法
//实例对象的方法
public java.lang.String proxyTest.StuDaoImp.getName(proxyTest.Stu)
public int proxyTest.StuDaoImp.getAge(proxyTest.Stu)
public void proxyTest.StuDaoImp.say()

//引用中的全部方法
public final void java.lang.Object.wait() throws java.lang.InterruptedException
public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException
public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException
public boolean java.lang.Object.equals(java.lang.Object)
public java.lang.String java.lang.Object.toString()
public native int java.lang.Object.hashCode()
public final native java.lang.Class java.lang.Object.getClass()
public final native void java.lang.Object.notify()
public final native void java.lang.Object.notifyAll()





o.getDeclaredMethods();只能获取实例对象中的全部方法(包括私有方法)
public java.lang.String proxyTest.StuDaoImp.getName(proxyTest.Stu)
public int proxyTest.StuDaoImp.getAge(proxyTest.Stu)
public void proxyTest.StuDaoImp.say()
private void proxyTest.StuDaoImp.pri()



//代理类的方法不同与被代理对象的方法,不能混调用

for(Method x:ms){
			//用实体类生成的Method数组依次调用没有问题
			//用代理类生成的Method数组会报异常
			x.invoke(ud);//没有问题
//			System.out.println(m);

//			代理类生成的数组也报异常debug
//			x.invoke(proxy);//异常  object is not an instance of declaring class
		}
//代理类的方法全部final修饰
0 : public final void com.sun.proxy.$Proxy0.add()
1 : public final boolean com.sun.proxy.$Proxy0.equals(java.lang.Object)
2 : public final java.lang.String com.sun.proxy.$Proxy0.toString()
3 : public final int com.sun.proxy.$Proxy0.hashCode()
4 : public final void com.sun.proxy.$Proxy0.update()
5 : public final void com.sun.proxy.$Proxy0.find()
6 : public final void com.sun.proxy.$Proxy0.delete()


//实体类自己的方法
0 : public void cn.itcast_06.UserDaoImpl.add()
1 : public void cn.itcast_06.UserDaoImpl.update()
2 : public void cn.itcast_06.UserDaoImpl.find()
3 : public void cn.itcast_06.UserDaoImpl.delete()

}
思想    模式
关联映射
集合创建出来的时候直接调用构造方法避免空指针异常

<计算机编程艺术>
1. tomcat:web.xml
DispatcherServlet  |StrutsPrepareAndExecuteFilter
CharacterEncodingFilter
自定义HTMLFilter(只有过滤器能过滤匹配路径以外的其他资源请求)
2. Spring: spring-*.xml



{

ApplicationContext  ClassPathXmlApplicationContext

StrutsPrepareAndExecuteFilter(Struts2主控制器)
						<!--一级目录要有/xxx,二级目录不需要/,否则报错,找不到路径  -->
<package name="demo" namespace="/demo" extends="struts-default">
        <!--由于使用Spring来管理Action，因此需要通过Spring
            容器来创建Action，因此class属性指定的是组件的ID。-->
        <action name="hello" class="helloAction">
            <result name="success">
                /hello.jsp
            </result>
        </action>
</package>


spring容器由DispatcherServlet来启动
整合struts后,主控制器由StrutsPrepareAndExecuteFilter代替,所以需要另外配置一个监听器(ContextLoaderListener)来启动spring框架
<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
  </listener>
  <context-param>
  	<param-name>contextConfigLocation</param-name>
  	<param-name>classpath:spring-*.xml</param-name>
  </context-param>

 <action name="hello" class="写class文件路径名,就是Struts管理,写bean的ID,表示有spring管理">
 <result name="ok"> /WEB-INF/xxx.jsp</result></action>
 result标签默认是转发的
 这两者都行,但spring有更强大的依赖注入和Aop事务管理
 用spring管理子处理器,必须要用原型@Scope("prototype")
Spring框架整合Struts2
Struts2主控制器StrutsPrepareAndExecuteFilter
struts2为了保证线程安全,每一个用户请求都需要单独写一个处理类,处理请求时创建对个(XxxAction)对象.每个线程独享一个子处理器的对象.
spring多请求共享一个处理器对象,spring利用参数注入解决线程安全问题
每个线程共享一个处理器对象,但传递的参数不同.
1. 如何接受用户的提交数据
	利用bean属性(特指访问对象属性的get,set方法)
	获取的数据利用set方法设置Action类中的属性值

getUv: null
setUv UserValue [name=null, password=null, age=null, address=null]
getUv: UserValue [name=null, password=null, age=null, address=qweds]
getUv: UserValue [name=null, password=null, age=32, address=qweds]
getUv: UserValue [name=yasuo, password=null, age=32, address=qweds]
execute: UserValue [name=yasuo, password=q2weds, age=32, address=qweds]
	
getUv: null
UserValue()
setUv UserValue [name=null, password=null, age=null, address=null]
setAddress
//UserValue [name=null, password=null, age=null, address=null]
getUv: UserValue [name=null, password=null, age=null, address=2额外的所]
setAge
//UserValue [name=null, password=null, age=null, address=2额外的所]
getUv: UserValue [name=null, password=null, age=23, address=2额外的所]
setName
//UserValue [name=null, password=null, age=23, address=2额外的所]
getUv: UserValue [name=yasuo, password=null, age=23, address=2额外的所]
setPassword
//UserValue [name=yasuo, password=null, age=23, address=2额外的所]
execute: UserValue [name=yasuo, password=1234abvc, age=23, address=2额外的所]


getUv: null
UserValue()
setUv UserValue [name=null, password=null, age=null, address=null]
setAddress
//UserValue [name=null, password=null, age=null, address=wedsc]
getUv: UserValue [name=null, password=null, age=null, address=wedsc]
setAge
//UserValue [name=null, password=null, age=23, address=wedsc]
getUv: UserValue [name=null, password=null, age=23, address=wedsc]
setName
//UserValue [name=wahaha, password=null, age=23, address=wedsc]
getUv: UserValue [name=wahaha, password=null, age=23, address=wedsc]
setPassword
//UserValue [name=wahaha, password=1234, age=23, address=wedsc]
execute: UserValue [name=wahaha, password=1234, age=23, address=wedsc]


Session储存数据



参数传递,直接使用Map<String,Object>map传入响应的request,session,application
StrutsPrepareAndExecuteFilter
C.ActionSupport

重写setXxxx方法
I.SessionAware
I.RequestAware
I.ApplicationAware


}

HTTP下载
<result-type name="stream" class="org.apache.struts2.dispatcher.StreamResult"/>


//展示图片
//下载图片
//下载Excel

struts原生不支持json,需要导入json的插件  struts2-json-plugin
该插件不需要再导入解析实体类为JSON字符串的包
<jsp:forward page = "newworld.jsp" ></jsp:forward>
jsp:forward可以实现页面跳转的效果 作用是转发 所以浏览器地址不会发生变化

<c:forEach items="${}" var="">


WEB Server
Apache(HTTP Server)   Nginx(HTTP Server)  Java Web 服务器(Servlet容器)Tomcat
}

jstl
//c.tld文件
JSP可以使用Struts标签,直接导入即可
<%@taglib uri="/struts-tags" prefix="s"%>
ValueStack
struts共享数据的机制,利用ValueStack可以在Struts组件之间共享数据
struts组件:
1. StrutsPrepareAndExecuteFilter
2. Action
3. result
4. 视图JSP
5. valueStack(控制器的属性存储位置)
配置文件 struts.xml

<s:property value="name" />


Element : rtexprvalue
Defines if the nesting attribute can have scriptlet expressions as a value, i.e the value of the 
 attribute may be dynamically calculated at request time, as opposed to a static value 
 determined at translation time. If not present then the default is "false", i.e the attribute has a 
 static value

Data Type : string
Enumerated Values : 
	- true
	- false
	- yes
	- no
	
OGNL(对象图导航语言)
在任何组件中
使用OGNL读取ValueStack数据的时候是按照从顶到下顺序查找,找到第一个匹配的就返回该值
尽量不要使用重复的属性名
Struts底层接管了EL和JSTL,将EL数据读取到ValueStack.EL的读取结果与ONGL一样

如果需要读取ValueStack的context区域,必须使用ValueStack  (#key)


JAVA EE是基础
spring是JAVA EE基础之上的简化框架(spring可以独立使用,但一般在JAVA EE环境中运行.JUNIT测试时是直接调用spring的)

WEB 开发需要java EE,多了两个jar包(jsp-api.jar和servlet-api.jar,定义了一些规范接口,具体需要服务器软件如Tomcat实现)

Struts(架子)
Mybatis
Spring
Hibernate(冬眠):以面向对象的方式操作数据库,不使用面向过程的sql
1. 不用写sql,但需要重新写hql(hql是基于sql的)
2. 会生成不理想的SQL,影响数据库性能
3. 特殊操作,无法实现
解决ORM问题(Object relation Mapping)对象关系映射问题
底层还是JDBC (SQL)

ClassPathXmlApplicationContext ac=new ClassPathXmlApplicationContext("spring.xml","spring-struts.xml");

servlet组件如何设置文件下载(2步):
1. response.setContentType("application/octet-stream");
2. response.setHeader("Content-Disposition","attachment;filename=\"img.png\"");

处理文件上传,需要导入两个包
commons-fileupload-1.2.2.jar
另一个是commons-io-2.0.1.jar
需要限定上传文件的类型和大小: 设置上传文件的拦截器

<action name="upload" class="">
    <interceptor-ref name="fileUpload">  
    <param name="allowedTypes">  
image/bmp,image/png,image/gif,image/pjpeg,image/jpg   
                </param>

  <param name="maximumSize">2048</param>//限定图片大小不能超过2k  
         </interceptor-ref>      
		 
         <interceptor-ref name="defaultStack"></interceptor-ref>  
         <result name="error">/error.jsp</result>  
         <result name="input">/upload.jsp</result>  
</action>  



//xhr.setRequestHeader("contentType","application/");
spring-mvc中;直接设置@RequestMapping(value="url" produce="application/octet-stream");
在方法体中设置响应头:response.setHeader("Content-Disposition","attachment;filename=\"img.png\"");




struts2中,设置action标签
<action name="" class="">
<result name="ok" type="stream" >
			//	这里的值img代表action类中的inputStream img 属性
	<param name="inputName">img</param>
	<param name="contentDisposition">attachment;filename="img.png"</param>
</result>


</action>

servlet组件文件上传


//没有该属性,必有该setXxx()方法
spring-mvc需要配置上传文件解析器MultipartResolver
org.springframework.web.multipart.commons.CommonsMultipartResolver
<property name="maxUploadSize" value="10000000"/>
    <property name="defaultEncoding" value="utf-8"/>
<form method="post" action="url" enctype="multipart/form-data">
MultipartFile

var file1 = $('#file1')[0].files[0];
	var file2 = $('#file2')[0].files[0];
	//创建内存中的表单对象
	var form = new FormData();
	//添加向服务器传输的数据
	form.append('userFile1', file1);
	form.append('userFile2', file2);

	
	Struts2提供了异常处理,但是基于网页的标准错误页面提示,不太友好,需要自己设置异常处理
	
	
	{
		配置连接池
		//MyBatis映射文件扫描可以写成/mappers/*.xml来表示该文件夹下全部映射文件
		MyBatis:
		整合spring需要配置的bean:
		1. sqlSessionFactory(dataSource,mapperLocations)
		2. MapperScannerConfigurer(sqlSessionFactory,basePackage)
		//基于spring AOP的事务管理
		3. DataSourceTransactionManager(dataSource)//基于连接池管理事务 
		//设置注解驱动事务管理
		4. <tx:annotation-driven transaction-manager="dataSourceTransactionManager" />
		
		//Hibernate映射文件只能写成list,一个一个写
		Hibernate
		1. LocalSessionFactoryBean(dataSource,mappingLocations,hibernateProperties[hibernate.dialect,hibernate.show_sql,hibernate.format_sql])
		2. org.springframework.orm.hibernate3.HibernateTemplate(sessionFactory)
		////基于sessionFactory管理事务
		3. org.springframework.orm.hibernate3.HibernateTransactionManager(sessionFactory)
		//设置注解驱动事务管理
		4. <tx:annotation-driven transaction-manager="dataSourceTransactionManager" />
		
		独立使用:
		1. Configuration builder=new Configuration();
		2. builder.configure(String path);//读取配置文件
		3. SessionFactory ssf=builder.buildSessionFactory();//创建SessionFactory
		4. Session ss=ssf.openSession();
		//Hibernate 默认不提交事务,需要手动开启Transaction对象
		//Transaction ts=ss.beginTransaction();
		// ts.commit();
	
	Configuration
	SessionFactory
	Session
	Transaction
	Query
	
		@Test
	public void findAll(){
		String hql="from User";
		List<User> list=ss.createQuery(hql).list();
		for(User u:list){
			System.out.println(u);
		}
	}
	//模糊查询
	@Test
	public void search(){
		String hql="from User where name like :name";
		Query query=ss.createQuery(hql);
		query.setString("name", "%皮%");
		List<User>list=query.list();
		for(User u:list){
			System.out.println(u);
		}
	}
	
	@Test
	public void search(){
//		String hql="from User where name like :name";
		String hql="from User where name like ?";
		Query query=ss.createQuery(hql);
	// query.setString("name", "%皮%");
		query.setString(0, "%皮%");
		List<User>list=query.list();
		for(User u:list){
			System.out.println(u);
		}
	}
		@Test
	public void findByName(){
//			String hql="from User where name= :name";
//			Query q=ss.createQuery(hql);
//			q.setString("name", "皮皮揭");
//			List<User> u=q.list();
//			System.out.println(u);
			
			String hql="from User where name=?";
			User u=(User) ss.get("lk.note.entity.User", "e2e46dfa-5dd3-4659-bc5d-079abcca4d0f");
			System.out.println(u);
	}
	//违反主键约束,后面更新的记录会替换掉原来id的记录
	79069dae-cca1-4d66-bc74-069bba9dcb28 | pipijuan     | 2b72fedca21db9bfdf86b52debf9e5e5 | NULL          | 皮皮娟       |
	e2e46dfa-5dd3-4659-bc5d-079abcca4d0f | pipijuan     | 2b72fedca21db9bfdf86b52debf9e5e5 | NULL          | 皮皮娟       |	
		
		回归性测试
		以前测试过在进行测试
	}
	
	Struts2拦截器(实现com.opensymphony.xwork2.interceptor.Interceptor接口,或者继承
	public abstract class com.opensymphony.xwork2.interceptor.AbstractInterceptor implements com.opensymphony.xwork2.interceptor.Interceptor)
	拦截器栈(多个拦截器一同工作,拦截器的容器)
	//系统拦截器有很多个
	拦截器:
	1. 拦截异常
	2. 记录地区/语言 zh_CN
	3. FileUpload
	4. Parameter 参数检查(把参数放入ValueStack)  Interceptor检查参数
	5. Validation
	
	
	Struts配置文件的书写有些元素必须按顺序书写,否则会报错.
	
	CAP(Consistency,Availability,Partitiontolerance)
	
				//把查询到的部分结果装入map容器,property as key,不写key则默认为0,1,2...
	String hql="select new map(bookId as id, name as name ) from Notebook where userId=?";
		
		@SuppressWarnings("unchecked")
		List<Map<String, Object>>list=hibernateTemplate.find(hql, userId);
		return list;
	
	
	Hibernate: 
    insert 
    into
        cn_user
        (cn_user_name, cn_user_nick, cn_user_token, cn_user_password, cn_user_id) 
    values
        (?, ?, ?, ?, ?)
Hibernate: 
    update
        cn_user 
    set
        cn_user_name=?,
        cn_user_nick=?,
        cn_user_token=?,
        cn_user_password=? 
    where
        cn_user_id=?
		
		
Hibernate延迟加载对象 Session.load(Object.class,Object primaryKey),实际上使用的是代理对象(只有id属性的空壳)，如果找不到就会抛异常（ObjectNotFoundExcepption）只有需要访问该对象的其他属性是才会访问数据库
Session.get(Object.class,Object primaryKey)使用的是实体对象,如果找不到该对象返回null

无论是load还是get，返回的对象都是持久状态	  (持久状态下不会修改主键)
//IdentityGenerator(Hibernate提供的主键自增)  <generator class="identity" />


标准js创建ajax请求:
1. 创建ajax对象 var xhr= new XMLHttpRequest();
2. 设置请求参数: xhr.open(url,method,true);
3. 设置回调函数: xhr.onreadystatechange=function(data){}
3. xhr.send(null);


$.ajax({url:"",data:"",dataType:"",success:function(){},error:function(){}})
$(selector).load(url,data,callback) 把远程数据加载到被选的元素中 
$.ajax(options) 把远程数据加载到 XMLHttpRequest 对象中 
$.get(url,data,callback,type) 使用 HTTP GET 来加载远程数据 
$.post(url,data,callback,type) 使用 HTTP POST 来加载远程数据 
$.getJSON(url,data,callback) 使用 HTTP GET 来加载远程 JSON 数据 
$.getScript(url,callback) 加载并执行远程的 JavaScript 文件 



Session是接口，hibernate框架提供的实现类是SessionImpl
Hibernate中Session的
Session是轻量级的，可以随意的创建和销毁
Session不是线程安全的


exclusion 排除，拦截器排除？
spring-mvc：


文件上传需要导入2个包,commons-fileupload 和commons-io

//上传文件解析器的配置
<bean id="multipartResolver"
    class="org.springframework.web.multipart.commons.CommonsMultipartResolver">

    <!-- one of the properties available; the maximum file size in bytes -->
    <property name="maxUploadSize" value="10000000"/><!-- 十万字节(一次上传的所有文件不超过10M) -->
    <property name="defaultEncoding" value="utf-8"/>
	</bean>

延迟加载:
OpenSessionInViewFilter

Hibernate更新的弊端:
需要传入一个完整的对象实体,全部属性都根据该对象更新.而如果只提交了该对象的部分修改属性,其他属性却被修改为null了
解决方案:
1. 在提交的表单中声明哪些属性是不需要更新的
<s:hidden name="OGNL"/> (如果不需要修改的字段很多,需要重复写,很麻烦)
2. 直接在映射文件ORM.xml中关闭更新<property name="" column="" update="false"/> (永久关闭该属性的更新了,其他业务要更新却无法操作)
3. 将orm映射文件的class类设置为动态更新属性(只在属性发生改变才更新,但只对持久状态下的对象有效)
因为表单提交的数据而创建的实体对象是临时状态,需要先用get(<T>,Serializable id)获取持久状态的对象,在用Spring的BeanUtils工具类
将临时状态对象的属性复制给持久状态对象完成更新
<class name="cn.tedu.note.entity.Note" table="cn_note" dynamic-update="true">
BeanUtils.copyProperties(Object source,Object target);



response.setContentType("text/html");
MIME类型以类型/子类型（type/subtype）的形式表示。

其中type表示一下几种典型文件格式的一种：

Text、Audio、Video、Image、Application、Mutipart、Message

Subtype则用来描述具体所用的数据格式。

Application/msword

微软的Word文件

Application/octet-stream  

一种通用的二进制文件格式(包括图片)

Application/zip

Zip压缩文件

Application/pdf

Pdf文件


CAP定理Consistency）， 可用性（Availability）， 分区容错性（Partition tolerance)
Check and 

ASM

缓存一致性问题:(多线程范文同一数据)
1> 内存上锁(锁总线)
2> 缓存一致性协议:Intel 的MESI协议

js的str.replace("a","0");//把str字符串中的第一个"a"替换为"0"
js的str.replace(/a/g,"0");//把str字符串中的全部"a"替换为"0"


接收页面参数值有3种方式
	使用request
	使用@RequestParam注解  eg:  public Object handleRequest(@RequestParam("password") String pwd)
	//不写注解默认从request中直接获取变量名的数据,如果没有则取得null,可作类型转换,如果是基本数据类型取不到值得抛出异常
	//写了@RequestParam("name")如果娶不到值直接抛异常
	使用实体对象(自动把接受的数据封装成对象)

向页面传出数据有3种方式
	使用ModelAndView对象 return new ModelAndView(String url,Map map);
	使用ModelMap对象    方法传入参数ModelMap,ModelMap.addAttribute(String key,Object value);
	使用@ModelAttribute注解 使用该注解,则每次匹配请求后执行service方法前都会先调用@ModelAttribute的方法
	在Controller方法参数上直接声明HttpSession即可使用
重定向有2种方式
使用RedirectView  return new ModelAndView(new RedirectView(String path));
使用redirect:  return "redirect: url";

转发的2个方法:
1> forward(request,response); //全部委托转发页面处理请求,此方法执行之后的request,response操作将不再生效
2> include(request,response);//保留本页面继续处理的权利

Mybatis中Dao对应的方法不可重载,如需要可变的参数可用动态Sql语句

intellij idea 激活服务器地址: http://intellij.mandroid.cn/

http://localhost:8080/jstest/breakpoint.html#顶部   //表示请求到该资源后定位到name="顶部"的锚点



数据库{
mysql{
字符串函数、数学函数、日期时间函数、搜索函数、加密函数、信息函数。

select @@tx_ioslation;--查看当前数据库的隔离等级
set session transaction isoalation level read commit;
1.串行化(序列化) 最高级别的隔离,效率最低,最安全(每个线程(事务)之间按顺序执行,一个事务结束后另外一个事物才能执行)
2.可以重复读取//MySql默认
3.读取提交后的数据(修改状态的数据读不到)//Oracle默认(并发和安全的平衡选择) 可以同时开启读和写的事务,但只能读取写入操作中提交的数据,可能在一次读的事务中,
4.可以读取修改中(未提交的数据)的数据(脏读)

1.脏读 (read commit)//针对update操作
2.不可复读(repeatable Read)//(update操作)
3.幻读(删除插入操作)//针对delete/insert操作


grant all on *.* to 'user10'@'%';最高权限

grant select on test.* to "lk"@localhost;
revoke select on test.* from "lk"@localhost;

revoke 权限1, 权限2..... on 数据库.表 from '用户名'@'IP地址';
grant  权限1, 权限2..... on 数据库.表 to   '用户名'@'IP地址';

create user 王舞 @'localhost'  identified by 'password';--创建本地用户
create user maliu@'IntAddress' identified by 'password';--创建指定ip地址的用户
create user maliu@'%' identified by 'password';--创建本地或远程用户

use mysql;
update user  set password=password("xxx") where user="likai";
flush privileges;

//登录数据库
mysql -u root -p database_name;
use database_name;



set autocommit=0;--设置自动提交事务为false;

begin start transaction

mysql没有非空函数,使用isnull(字段,null时取出的值);



alter table emp add column_name after column_name_exists;  //把新的字段添加到已存在的字段后面



select case cn_note_status_id when "1" then "ss" when "0" then "00" else "" end from cn_note;
							if(boolean 表达式	,true , false)
select if(cn_note_status_id="1","ok","error") from cn_note where cn_note_id="fed920a0-573c-46c8-ae4e-368397846efd";

按小时分组select date_format(hiredate,"%Y%M%D%H") hour,count(*) num from emp group by hour;


//增加索引
create index idx_ename on table_name(column);
alter table table_name add index idx_name (column); 

索引是B tree ,模糊查询步骤 B tree
index full scan 可以走模糊查询

//建立临时表
create temporary table tem_table_name ();


case语句
case column when  xxx then xxx when xxx then xx  else  xxx end

}

oracle{
	like "%xxxx" 列索引失效
	index full scan
decode(column,case a,do a,case b,do b,全部不匹配默认执行);
case column when  xxx then xxx when xxx then xx  else  xxx end


笛卡尔坐标系:
表a的记录数*表b的记录数

exec dbms_stats.gather_table_stats('SYS','T1');

}

}

jdbc{
driverClass
url
user
password

数据库连接池: DataSource(配置连接池)

dbcp : BasicDataSource
c3p0:  ComboPooledDataSource
spring-jdbc：连接池　 DriverManagerDataSouce
iBatis : 	PooledDataSource
}



//常用程序的端口号
oracle: 1521
mysql: 3306
tomcat: 8080  (80)

过滤器是基于回调,拦截器是基于反射

位运算符: ^ & | ~ << >> >>>


java对象的比较排序必须要实现Comparable接口,否则会报异常:
java.lang.ClassCastException: demo04.Emp cannot be cast to java.lang.Comparable
原理:比较对象时需要用到Comparable接口的实现方法(Comparable内部比较器)

Comparator接口(外部比较器,临时创建的比较器)
比较两个对象的大小

集合框架里面用的比较多


javascript

数组排序:
js数组存放的元素可以是任意对象
var array=[1,21,11,56];
array.sort();
从数字的最高位数字开始比较,不是比较数值
需要传入比较函数
array.sort(function(a,b){return a-b;});

[null, 1, true, 2, "3", 9, 21, NaN, undefined]
null<false=0<true=1<NaN<undefined
null-NaN=NaN;

//任何数字与undefined计算结果都为NaN;

null+undefined
NaN
null+false
0
undefined+undefined
NaN

//js检查表单提交的数据
<script>
function validateForm(){
var x=document.forms["myForm"]["fname"].value;
if (x==null || x==""){
  alert("姓必须填写");
  return false;
  }
}
</script>

background-attachment 有三个值，scroll是默认值，背景图像会随着页面其余部分的滚动而移动。 fixed当页面的其余部分滚动时，背景图像不会移动。 inherit规定应该从父元素继承 background-attachment 属性的设置。 background-origin 属性规定 background-position 属性相对于什么位置来定位。 background-clip 属性规定背景的绘制区域。
字符串与数字不能进行判断,编译错误;

哈希查找的时间复杂度为O(1);
java垃圾回收机制采用分代收集,其中堆大概分为两代
 虚拟机中的共划分为三个代：年轻代（Young Generation）、年老点（Old Generation）和持久代（Permanent Generation）。

2位的十六进制数就是一个字节：0x12&0x0f结果为0x12的的后四位
 
 switch 参数类型:byte,short,int,String,char,enum,Byte,Short,Integer,Character共10种
 
 
1.数据类型
	1.1基本数据类型
	1.2引用数据类型
	
	int 与Integer对象==比较,Integer对象自动拆箱用int值比较
	
	Integer对象与Integer对象==比较,比较的是引用
	Integer对象维护了一个byte常量池,-128到127范围的值
	通过Integer i=127;Integer i2=127;这样的对象==结果为true
	
	超出范围,则为false
	其他所有new出来的地址值一般都不同
	
	
	Long 的常量池范围为Integer.MIN_VALUE~Integer.MAX_VALUE;
	
	int 转 字符串
	int x=1;
	String str=String.valueOf(x);
	String str=Integer.toString(x);
	String str=x+"";
	
	字符串转成数字:可能失败,抛出异常throw new NumberFormatException();
	String str="12";
	int x=Integer.parseInt(str);
	int x=Integer Integer.valueOf(str);//这里做了自动拆箱
	
	日期转成格式化字符串
	Date d=new Date();
	SimpleDateFormat sdf=new SimpleDateFormat();
	String str=sdf.parse(str); throw new ParseException() extends Exception;
	Date d=sdf.format(d);//格式化日期

2.数据状态
	2.1常量
		字面值常量(整数,小数,布尔值true,false,字符,字符串,)
		自定义常量(final修饰的变量)
	2.2变量

	null状态,undefined

3.关键字,标识符,命名法,修饰符

4.线程
Exception: InterruptedException
		   ConcurrentModificationException
		   
		 
		   
实现多线程的方式:
1. 继承Thread类
2. 实现Runable接口
3. 实现Callable接口通过FutureTask包装器来创建Thread线程
4. 使用ExecutorService、Callable、Future实现有返回结果的多线程。


通过 Callable 和 FutureTask 创建线程
1. 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值(返回值为泛型)。
2. 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。
3. 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。
4. 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。



	线程通信:不同种类的线程对于同一个资源的操作
	多线程:
	同步,异步
	死锁
	线程池:


5.异常

6.IO

7.sql
{
	一.添加约束
在字段定义完毕后直接添加 constraint student_id_pk primary key
在所有字段定义完毕后添加constraint student_sex_ck check (sex in('f','m'))

为表格(service)的字段accountid添加外键约束(account 的字段accountID)方法:
 A.直接在定义字段后添加 REFERENCES account(accountid)
 B.在表所有字段定义结束后添加 FOREIGN KEY(accountid) REFERENCES account(accountid)
 C.在表创建后执行如下命令：ALTER TABLE service ADD FOREIGN KEY(accountid) REFERENCES account(accountid)

PreparedStatement 设置字段属性的时候自动进行数据类型匹配检查
Statement执行sql语句的时候是直接传入一个字符串的，不存在对传入数据类型的检查
PreparedStatement void setObject(int index,Object o);
PreparedStatement void setInt(int index,int i);


create trigger tr_stu_sex before insert on stu for each row begin if new.sex not in ('M','F') then insert into stu(id) values(1);

select name from stu ,(select a.sid  sid from (select score,sid from score where cid=1)a,(select score ,sid from score where cid=2)b where a.sid=b.sid and a.score>b.score) r where stu.sid=r.sid

连接池:
dbcp: new BasicDataSource();
c3p0: new ComboPoolDataSource();

Statement
PreparedStatement
CallableStatement(继承于PreparedStatement)
String callSql="{call sp_name(?,?,?)}";

Types存了数据库字段数据类型与java数据类型的对应

数据库SQL:  ojdbc
连接池需要导入两个外包(dbcp)


Oracle:
driver=oracle.jdbc.driver.OracleDriver  
url=jdbc:oracle:thin:@IntAddress:port:sid  
//两种连接模式：thin模式(不需要oracle客户端)和oci模式(需要oracle客户端)
user=
pwd=
日期的默认格式:  
1:  "27 11月 1992"  | "27-11月-1992"     (中文环境下)
2:	"27 Feb 1992"   | "27-Feb-1992 "     (英文环境下)


MySql
driver=com.mysql.jdbc.Driver
url=jdbc:mysql://IntAddress:port/sid
user=
pwd=

日期的默认格式:  
1: "19921127"     (不能空格)
2:"1992-11-27 "       
MySql没有序列(Sequence),利用  to_increment  自动生成主键 (必须与主键配合使用,且只能增不能减,每次只能自增1) 
alter table emp modify  empno int auto_increment primary key
insert into emp (ename,job,sal)values("张三","工人",4000)     --不用写出empno号
insert into emp values(null,'haha','haha',1234,"1992-11-27",234,null,20)   --全部数据写入的话empno需要写入null让系统自动生成

 oracle默认null为最大值,mySql默认null为最小值
 
 mysql:
 select * from emp order  by mgr desc limit m;  --扫描表内符合条件的(<=m)条记录并取出（有可能符合条件的记录不足m条）
 select * from emp order  by mgr desc limit m,n;--扫描表内(m+n)条符合条件的记录，并取出最后n条记录
 
 
}
8.jdbc


9.反射
reflect

Class 类
Constructor
Method
Field

Annotation 



动态代理:
jdk中动态代理的实现依赖于一个实体工具类Proxy以及一个InvocationHandler接口



10.Servlet
{
	
	jsp：
	SimpleTagSupport
	
	
cookie大小有限制(4k),数量有限制,只能存字符串,可以被用户禁止
Servlet默认设置cookie的有效时长为-1,保存在内存中
禁用session,使用url重写来提交sessionid http://localhost:8080/test/some;jsessionid=4E113CB3(在url后面加上分号)
生成链接地址和表单提交时，使用如下代码：
<a href=”<%=response.encodeURL(String url)>”>链接地址</a>
如果是重定向，使用如下代码代替response.sendRedirect()
response.encodeRedirectURL(String url);


get方式提交数据,是可见的,有大小限制(2k),使用路径直接传递参数
浏览器第一次访问服务器,服务器为期创建一个session对象,里面储存了sessionID,响应时将这个
sessionid保存在response对象里面.浏览器收到的响应头数据中set-cookie里面存的就是sessionid的信息

立刻删除Session对象 void Session.invalidate();
session的有效时间在Server(Tomcat)的web.xml文件中配置(默认缺省时间为30分钟)
 <session-config>
        <session-timeout>30</session-timeout>
  </session-config>

服务器的时间和时区设置可能影响Cookie，IE而言，Cookie的有效时间段是理解为客户端的时间与服务器端时间的间隔，对于FireFox而言，Cookie的有效时间完全由服务器端的时间决定

//jackson-API解析(对象转换为json字符串,将json字符串转换成对象)
response.setContentType(String type); //  text/html | image/png  application/json
ObjectMapper mapper=new ObjectMapper();
String json=mapper.writerValueAsString(Object);


//gjson(谷歌出品的json工具)
Gson tool=new Gson();
String json=tool.toJson(Object o);


//fastjson(阿里巴巴出品的解析json工具)

摘要加密
//不适合数据加密传输
摘要加密的特点：不适用密钥，使用摘要加密算法对明文进行加密之后会得到密文，无法反推出明文。唯一性：不同的明文有不同的密文。不可逆性：即使知道了摘要加密算法，也无法反推出明文。
1.4.2. 如何实现摘要加密
public class MD5Util{
    private static void test1() throws NoSuchAlgorithmException{
        String str = "I love you";
        MessageDigest md = MessageDigest.getInstance("md5");
        //依据指定的加密算法进行加密
        byte[] buf = md.digest(str.getBytes());
        //因为字节数组不方便使用，所以，将其转换成一个字符串
        //BASE64Encoder的encode方法可以将任意的一个字节数组转换成一个字符串
        BASE64Encoder  base = new BASE64Encoder();
        String str2 = base.encode(buf);
        System.out.println(str2);
}
    public static String encrypt(String  origStr){
        MessageDigest md = MessageDigest.getInstance("md5");
        byte[] buf = md.digest(str.getBytes());
        BASE64Encoder  base = new BASE64Encoder();
        String str = base.encode(buf);
        return str;
    }
}
}

11.html
{
<form>标记中有如下常用属性。
Action:用于确定表单的提交目的地址
Method:用于指定表单数据的提交方式，常用有get/post/(put,delete)
Enctype:用于指定表单数据的编码类型。

js获取cookie
document.cookie;//返回一个cookie字符串
var cookieArray=document.cookie.split(";");//把cookie字符串分割成cookie字符串数组

escape(str);//对字符串进行编码


}



子类创建对象默认会访问父类的无参构造方法,但并没有创建父类的对象（创建对象需要用到关键字 new ）
new Foo()  和Foo()的区别,new表示创建了对象,在内存开辟了空间,Foo()仅仅表示调用构造方法,把成员变量初始化后赋值给子类对象

{一个类中若没有声明其构造方法,则编译器默认会自动为其添加一个public修饰的无参构造方法,很多框架可以调用该无参构造方法创建对象}
spring框架创建对象时会通过反射机制暴力调用构造器或者静态工厂方法(无视权限)


多态,解耦(传入最大的接口,方便后续代码的维护,传入的实体对象实现类有可能以后需要修改)






class文件的装载:
1.加载.class文件进内存
2.连接 检查内部结构,为静态成员分配空间,设置默认初始值,符号引用替换为直接引用
3.初始化 



类加载进方法区:
首先执行静态变量(先默认初始化,然后进行自定义的显示初始化(如果有的话))和静态代码块(平级关系,按书写的先后顺序执行) 
静态变量的默认初始化和静态代码块的执行不论他们在文件中的顺序
static int x(=0;);static {} 
然后再执行构造代码块和成员变量
最后在执行构造方法
1.static {静态变量,静态代码块(在class文件进方法区后执行且只执行一次)}
2.{成员变量,(构造)代码块(每次创建对象时调用)}
3.(public) Class_Name(){构造方法(每次创建对象之后调用)}
 
new Zi(); //创建子类对象,首先加载父类,访问其构造方法super();
Foo.static代码块
Zi静态代码块
Foo构造代码块
Foo构造方法
Zi构造代码块
Zi()构造方法

首先加载父类和子类的全部static代码块

抽象类实现了某个接口,该接口的方法可以在抽象类中不写,默认存在该抽象方法
 

(二进制数)  				正数       负数
计算机显示:		原码				
过渡值:			反码		不变	原码的1变0,0变1,最高符号位的1不变
计算机识别值:		补码		不变	反码数值加1,最高符号位的1不变
进行逻辑运算(&,|)时,0相当于false,1相当于true
位异运算符(^),一个数与另一个数连续位异两次,其值不变  
eg:  a=a^b;
	 b=a^b;  //a^b^b=a;
	 a=a^b;	//a^b^a=b;
<<,>>,>>>

 
查看本机IP地址:
linux    ifconfig
windows  ipconfig     
查看端口:netstat -ano  (中间'-'前面有空格)

html
特殊实体符号:  &emsp(大空格)    &nbsp  &lt &gt  
<pre>
pre 元素可定义预格式化的文本。被包围在 pre 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。
标签的一个常见应用就是用来表示计算机的源代码。
</pre>
<hr/>定义水平线



Servlet
http://IntAddress:port/app-name/url-pattern
302:重定向      
 void javax.servlet.http.HttpServletResponse.sendRedirect(String path) throws IOException
错误:
404:(服务器找不到地址) 
项目没有部署 自定义Servlet对象书写不规范或者没有在web.xml配置文件书写或者书写不正确   网络路径写错


HttpServlet.getServletContext()==GenericServlet.getServletContext()
==GenericServlet.getServletConfig().getServletContext()
ServletContext接口的数据是所有网站自定义Servlet对象共享的
  getServletContext()     getAttribute(String para-name)    setAttribute(String para-name,object para-value)
  
  获取配置文件的参数: Object.getInitParameter(String name);
  
其中,setAttribute(String para-name,object para-value)方法中如果传入数字并且自增,需要用setAttribute("count",++count),
如果用setAttribute("count",count++),这不发生自增(值不变)  每次获取到的值为0  (只对count有效)


ServletContext 定义属性的方法:
1.在servlet类当中获取     getServletContext().setAttribute(String para-name,object para-value);
2.在web.xml配置文件中直接书写
<context-para>
<param-name></param-name>
<param-value></param-value>
</context-para>

Servlet类加载的优先顺序在
<servlet>
<load-on-startup>1</load-on-startup>
</servlet>
数值必须大于等于1,如有相同优先级的,则按xml先后顺序加载,如果是其他数字或者字符串,则不能识别,只能在第一次访问时加载


XML解析方式
1. SAX解析方式
SAX（simple API for XML）是一种XML解析的替代方法。相比于DOM，SAX是一种速度更快，更有效的方法。
它逐行扫描文档，一边扫描一边解析。而且相比于DOM，SAX可以在解析文档的任意时刻停止解析。 
优点： 解析可以立即开始，速度快，没有内存压力
缺点： 不能对节点做修改  ????
2. DOM解析方式
DOM：(Document Object Model, 即文档对象模型) 是 W3C 组织推荐的处理 XML 的一种方式。DOM解析器
在解析XML文档时，会把文档中的所有元素，按照其出现的层次关系，解析成一个个Node对象(节点)。
优点:把xml文件在内存中构造树形结构，可以遍历和修改节点
缺点： 如果文件比较大，内存有压力，解析的时间会比较长


jQuery

$(":button:eq(0)").attr("value","+")
obj.remove();  obj.remove(SELECTOR);
obj.empty();
e.stopPropagation();
e.target;//DOM对象
e.pageX
e.pageY

$("#id_value").subling

回调函数
animate




Servelet  SpringMVC  Struts

静态网页:维基百科,百度百科,小说,新闻,开发手册网页
服务器保存一份HTML文件,响应请求时直接发送该文件

********
动态网页:显示内容因人而异
ObjcetInputStream  ObjectOutputStream 
transient  
服务器保存一个对象,由该对象动态拼成一个网页,发送给浏览器
在java中该对象是 Servelet

Servelet: 满足(SUN|Oracle)规范的对象是组件
储存在服务器上,可以动态的拼接资源(HTML,IMG).  处理HTTP协议

Servelet: SUN推出的用来在服务器端处理HTTP协议的组件(动态网页)


服务器:  本质是一个软件:可以运行Java(WEB)项目的软件运行环境(JAVAEE)
-Tomcat(Apache)
-JBoss
-WebLogic
-WebSphere

Tomcat:本质是软件,可以直接运行使用
1.单独使用(很麻烦):在软件上线的时候在独立运行
2.通过Eclipse管理***

Apache 是 PHP 程序运行的服务器，IIS 是.net 程序运行的服务器

Servlet:  
Tomcat: 加权限:  chmod +x *sh
sh shutdown.sh


URIEncoding="UTF-8"
Cookie URLEncdoer.encode("张三","utf-8");  URLDecoder.decode("张三","utf-8");
1.创建一个Maven项目, war类型打包封装
2.generat deployment(部署web.xml文件)
3.properties target apache(引入javaee的jar外包)
4.new class extends HttpServlet
5.@override
protected void Service(ServletRequest req,ServletResponse rep)throws ServletException,IOException{}

Tomcat服务器本身并不能调用私有构造方法创建对象
	
void Servlet.init(){}  方法,用来接收Tomcat容器传递过来的ServletConfig对象
里面储存了初始化信息(init-param标签内param-name value值)
http协议,还有别的协议比如ajp
Servlet接口:负责服务器与Java代码通信的规则
GenericServlet类:一般的Servlet类
HttpServlet类:专门处理http协议的servlet类
service方法:负责管理请求方式并分别处理的(service是请求的中转站(转交业务给doPost方法和doGet),当然本身也可以直接处理业务)
String method=req.getMethod();
		if(method.equals("Get")){
			doGet(req,rep);
		}
		else{
			doPost(req,rep);
		}
全局属性:项目内全部Servlet对象公共属性ServletContext 被封装进request对象自动传入service(request,response)方法内	
<context-param>
  <param-name></param-name>
  <param-value></param-value>
 </context-param>

配置Servlet对象
<servlet>
  <servlet-name>html</servlet-name>
  <servlet-class>web.HTMLService</servlet-class>
  Servlet类私有属性:ServletConfig  servlet对象初始化后调用Servlet.init(ServletConfig config){}方法传入
  <init-param>
	<param-name></param-name>
	<param-value></param-value>
  </init-param>
  <load-on-startup></load-on-startup>
</servlet>
<servlet-mapping>
  <servlet-name>html</servlet-name>
  <url-pattern>/html</url-pattern>
</servlet-mapping>
异常处理页面
<error-page>
	<exception-type></exception-type>  java异常类型   ||  <error-code>404</error-code>  //网页错误代码
  	
  	<!-- 转发的路径前缀一定是在该项目之内的 (错误页面必须写绝对路径,并且省略项目名(tomcat自动加的项目名))-->
  <location>/WEB-INF/error.jsp</location>
</error-page>
request的getReader()方法和getInputStream()方法
直接采用req.getReader()方法和 req.getInputStream()方法得到的数据不能正常显示(编码表没问题)
1>不显示数据(只能读取post方法提交的数据),而且读取完毕之后就没有数据了,不能复读
JSTL
<c:if test="判断条件">执行语句</c:if>
<c:choose >
<c:when test="判断条件">执行语句</c:when>
<c:when test="判断条件">执行语句</c:when>
<c:when test="判断条件">执行语句</c:when>
<c:
</c:choose>
<c:otherwise >执行语句</c:otherwise>

WEB-INF文件夹下的资源不能被浏览器直接通过路径访问到,起到对重要数据的保护作用
ServletConfig接口的是实现类对象在自定义的Servlet类创建唯一对象的时候由Tomcat自动创建,并在Servlet
调用init(ServletConfig condfig){}时自动传入并被Servlet类对象保存,然后这个
form表单的提交方式:
1.<input type="submit" />
2.超链接js绑定提交事件<a href="javascript:document.form[0].submit();">超链接名字</a>
	如果表单提交需要先通过函数验证数据,则需要改为onsubmit();
server.xml
URIEncoding='utf-8'



地址错误（拼写不正确，字母大小写错误）。
web.xml文件中的<servlet-name>不一致。
工程没有部署。
Web应用程序部署结构没有遵守Servlet规范。
service方法名称写错。
service方法参数类型与标准不一致。
service方法异常、返回值类型与标准不一致。
Servlet类没有继承HttpServlet或实现Servlet接口
web.xml文件中的<servlet-class>写错
service方法中的代码运行时抛出异常


Cookie的有效路径指的是产生该Cookie对象的网络路径及全部该路径以下的子路径(默认情况下)
Cookie的有效路径可以通过setPath(String path)重新定义

(
Integer i=1;
int i1=1;
System.out.println(i==i1);  //编译不报错结果为true
)

(
    int a=9;
		int b=11;
		boolean flag=a++>b--&&b++>a--; 
		//false  逻辑短路,后面不执行
		    System.out.println(flag+",a="+a+",b="+b);
		    //false  a=10,b=10   先进行判断,在自增自减
)

(
long l = 999999;  //编译不报错,数值在int范围内,自动转换为long

)

 //线程安全的类:Vector,Hashtable,BlockingQueue

truncate table t_name  --删除表格的全部数据不删表格,不可回退


Servlet{
请求方式:请求方式不同,服务器处理请求时采用的缓存也不同,提高响应速度
在HttpServlet中,service方法默认会根据请求方式不同而调用不同的doXXX方法
GET
POST
HEAD
PUT
DELETE
OPTION
TRACE

JSP9大内置对象
1.page
2.request
3.session (HttpSession)
4.application (ServeltContext)
5.config
6.pageContext(存取其他的内置对象,本身不能存储数据)本身是抽象类
7.response
8.out 
9.exception (ServletException,IOException)

Servelet(Jsp)中可以保存数据的三个不同的作用域(必须要有setAttribute(String,Object)):
1.request
2.session
3.context


cookie的值只能是ASCII字符，中文需要转换成ASCII码形式，使用URLEncoder.encode()方法和URLDecoder.decode()方法实现
cookie和session是为了解决多个request或者多个servlet类之间传递信息的问题:http协议是一个无状态协议,即服务器默认不会记住浏览器.
cookie和session是用来进行状态管理的
什么是状态? 状态就是浏览器访问服务器的证据(数据)
//浏览器首次访问服务器时,服务器(Tomcat)会自动给访问的浏览器创建一个session对象,并将session对象的SessioinID自动添加到response对象上发送给浏览器,此时会被监听器监听
servlet可以通过
request.getSession()方法来获取session对象的数据(JSESSIONID)
	javax.servlet.http.HttpSession session=req.getSession();
		//session是jsp9个内置对象之一,可以存储任意类型的数据(Object,需要转型)
		session.setAttribute("user", user);
		
		//服务器做出响应时,会自动创建Cookie对象,传入sessionID,设置路径为全局路径,并传给response对象一起发送给浏览器
	/*	Cookie c=new Cookie("JSESSIONID",session.getId());
		  c.setPath("/jsp5");
		  rep.addCookie(c);*/

session缺省时间设置:
1.web.xml配置文件  
<session-config>
	<!-- 这里的数字代表的是分钟 默认设置是30分钟-->
	<session-timeout>1</session-timeout>
</session-config>
2.servlet类当中单独设置
void Session.setMaxInactiveInterval(int seconds)	
URL重写:浏览器禁用cookie,服务器通过URL重写发送SESSIONID


监听器:
监听session,request,context对象的创建和销毁
监听session,request,context对象属性的更改(创建,移除,设置)


第一次请求net不会有记录?


如何生成验证码:
<img src='/createImg.do' title='点击更换' alt='验证码' onclick='this.setAttribute('src','createImg.do?num='+Math.random())'>
'createImg.do?num='+Math.random()这里是生成不同的请求
rep.setContentType("image/png");
		OutputStream os=rep.getOutputStream();
		ImageIO.write(image, "png", os);

公共业务:很多请求都需要进行处理的业务(登入检查,日志)
Servelet:处理请求
Filter:处理公共业务
一般为了降低耦合度
多个过滤器联用,按照web.xml配置文件中<filter-mapping>出现的先后顺序依次过滤
		
}

WEBbasic{
DOM对象:针对(html结构的)CRUD操作
(Document(8),Node(所有的对象都可以都是Node对象(包括元素标签,元素属性,元素文本,)),ElementNode(1),AttributeNode(2),TextNode(3),CommentNode(9),NodeList)
1.C  document.createElement();
		
2.R  document.getElementById("");
	 document.getElementsByName("");//通过name属性获取元素
	 document.getElementsByTagName("");
	 document.getElementsByClassName("");
3.U 

4.D  
创建函数的三种方法:
1:var f=new Function("a","b","return a-b;");
2:function f(a,b){return a-b;}  定义一个名字为f的方法
var f=function(a,b){return a-b;}
3.匿名函数  new function("a","b"){return a-b;}  不能用变量接收

创建一个Option对象var o=new Option("aa", 18);  //第一个变量表示下拉选的选项文本值为"a",value属性为18
向id="select"的元素上增加子元素option方法:
document.getElementById("select").add(o);
document.getElementById("select").appendChild(o);

html 页面上有一个 id 值为 s1 的 <select> 元素，现需要使用 JavaScript 代码清空其所有选项，
下列选项中，错误的是（B）。(options是元素的特殊属性,不可以被直接设为null状态.该属性是一个数组，可以通过设置数组的长度为0来清除数组中的元素，但是，不能试图去掉该属性。)
 A.document.getElementById("s1").options.length = 0;
 B.document.getElementById("s1").options = null;
 C.while (document.getElementById("s1").options.length > 0) {
		document.getElementById("s1").remove(0);
    }
 D.var selObj = document.getElementById("s1");
   while (selObj.childNodes.length > 0) {
             selObj.removeChild(selObj.lastChild);
   }

location.href=""  //保留浏览历史
location.replace=""  //不会保留浏览历史
history.go(x)  //只能前往已访问的地址  x可以为数字(正整数表示前进,负整数表示后退,url字符串直接前往该地址(如果访问过))

WEB{
html网页中如果多个元素设置同value值的id属性,css中id选择器会全部获取这些元素,js中的id获得器则根据上下文顺序只会获取第一个元素
HTTP三点注意事项：
1.HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
2.HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。
3.HTTP是无状态(所以需要session和cookie来记住状态)：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。



<br />换行标签
<hr />加一根水平线
JS(内置大量对象,无需编译,由浏览器引擎(内核)逐行执行):
1.客户端的数据运算
2.客户端表单数据验证
3.浏览器事件触发
4.网页特殊效果制作
5.服务器异步数据提交(ajax)

js可以直接在事件定义时,也可以嵌入html文件中<script>,最好是引用js文件<script src="../.js">

js是解释性代码,代码错误,页面将没有效果

js事件:
1.鼠标事件
2.键盘事件
3.窗口事件
onabort	图像加载被中断	1	3	4
onblur	元素失去焦点	1	2	3
onchange	用户改变域的内容	1	2	3
onclick	鼠标点击某个对象	1	2	3
ondblclick	鼠标双击某个对象	1	4	4
onerror	当加载文档或图像时发生某个错误	1	3	4
onfocus	元素获得焦点	1	2	3
onkeydown	某个键盘的键被按下	1	4	3
onkeypress	某个键盘的键被按下或按住	1	4	3
onkeyup	某个键盘的键被松开	1	4	3
onload	某个页面或图像被完成加载	1	2	3
onmousedown	某个鼠标按键被按下	1	4	4
onmousemove	鼠标被移动	1	6	3
onmouseout	鼠标从某元素移开	1	4	4
onmouseover	鼠标被移到某元素之上	1	2	3
onmouseup	某个鼠标按键被松开	1	4	4
onreset	重置按钮被点击	1	3	4
onresize	窗口或框架被调整尺寸	1	4	4
onselect	文本被选定	1	2	3
onsubmit	提交按钮被点击	1	2	3
onunload	用户退出页面	1	2	3

事件冒泡:子节点的事件出来完毕后会依次向上抛给父节点的事件函数处理;可以取消事件冒泡
e.stopPropagation();  //e表示事件对象


js事件函数:
bind(type, [data], fn)   //绑定事件函数   $obj.bind('click',function(){});可简写成$obj.click(function(e){}); 可以向点击函数传入参数e,表示事件对象event,e.target表示事件源,e.pageX,e.pageY表示点击的坐标
one(type, [data], fn) 
trigger(type, [data]) 
triggerHandler(type, [data]) 
unbind([type], [data]) 

jQuery对象函数:
$obj.hide();
$obj.empty();

读写节点
$obj.html();
$obj.text();
$obj.val(); //读取value属性值
$obj.attr(key); //读取key属性值  



$obj.next();
$obj.sibilings();



infinity


js五种基本类型(原始类型primitive )：
String boolean number null undefined (null和undefined是特殊的数据类型)
还有2种复合数据类型:function和object  

js对象

Date
表格:
单元格边距(表格填充)
(cellpadding) -- 代表单元格外面的一个距离,用于隔开单元格与单元格空间单； 元格间距(表格间距)
(cellspacing) -- 代表表格边框与单元格补白的距离,也是单元格补白之间的距离。 
<input type="button" value="按钮" onclick="f1();" />
等价于<button onclick="f1();">按钮</button>
open() 方法用来初始化 HTTP 请求参数,但是并不发送请求。

var xmlhttp;
	if (window.XMLHttpRequest)
	{
		//  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码
		xmlhttp=new XMLHttpRequest();
	}
	else
	{
		// IE6, IE5 浏览器执行代码
		xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
	}
	xmlhttp.onreadystatechange=function()
	{
		if (xmlhttp.readyState==4 && xmlhttp.status==200)
		{
			document.getElementById("myDiv").innerHTML=xmlhttp.responseText;
		}
	}
	xmlhttp.open("GET","/try/ajax/ajax_info.txt",true);
	xmlhttp.send(null/data);
$.ajax({ url:'findById',  type:'GET',  data:{'id':$('#cb1').val()}, dataType:'json', success:function(data,statusText){ //待补充 }, error:function(xhr,e1,e2){ alert('系统错误'); } });

}

}



Spring{
扫描包内(包括子包)所有包含注解Component的类并添加到spring框架管理
<context:component-scan base-package=""/>
<mvc:annotation-driven/> MVC的相关注解比如@RequestParam才生效



所有的对象都可以被设为bean元素,比如class,集合<util:list id="">.
创建对象的方式(反射机制强行创建对象(无视权限))
	1.无参构造<bean id="" class=""/>  (name属性废弃不用了,class必须是带包名的class文件路径)
	2.静态工厂方法(必须有static修饰,否则报错)创建对象<bean class="" factory-method=""/>
	3.实例工厂方法<bean factory-bean="bean_id"  factory-method=""/>

scope="singleton"(默认)  |"prototype" (原型)

lazy-init="false" (默认) |"true" 
	
配置文件<bean>标签属性
<bean  id="date(唯一约束)"  class="java.util.Date(带包名的类路径名)" scope="singleton(不写默认,单例模式,)| prototype() "
	lazy-init="true(默认为false,单例模式下自动创建对象)"	init-method="初始化自动调用的方法名"  destroy-method="方法名 容器关闭前调用此方法销毁对象(只在单例模式下有效)"
    />
描述Spring框架的作用和优点。
Spring框架的作用和优点如下：
1. Spring是一个开源的轻量级的应用开发框架，其目的是用于简化企业级应用程序开发，减少侵入；
2. Spring提供的IoC和AOP应用，可以将组件的耦合度降至最低，即解耦，便于系统日后的维护和升级；
3. Spring为系统提供了一个整体的解决方案，开发者可以利用它本身提供的功能外，也可以与第三方框架和技术整合应用，可以自由选择采用哪种技术进行开发。


静态工厂方法创建对象factory-method=""(该方法必须是static修饰的,否则就没有意义)

scope="singleton"|"prototype"|"session"|"request"|"global Session"

lazy-init属性对原型无效(scope="prototype")
destroy-method属性只对单例(singleton)有效

init-method属性对原型有效,在创建对象时自动调用

set方法注入(最常用),class中setXxxx(Object o)方法必须是public修饰的
构造器注入,无视构造方法的访问权限
autowise:自动装配 表示容器自动建立对象之间的依赖关系 byName:依据属性名(bean id)查找相应的bean( 以属性名作为bean的ID来查找,找到之后调用set方法来建立依赖关系) 
		最终还是采用set方法 tips:如果找不到则不注入 byType:依据属性的类型来查找相应的bean,找到之后,调用set方法
		通过类型查找到两个或两个以上的bean则会不报错,特别是存在继承,实现关系的父子类上,同时符合父类 -->
		<!-- constructor:与byType类似,通过类型查找匹配的bean对象,在多态环境下容易发生异常(匹配到多个合适的bean)只不过调用构造器来注入 -->
		<!-- 默认不注入 -->

autowire="no"(默认)|"byName"|"byType"|"constructor"|"autodetect"

<util:properties location="classpath:config.properties">


组件扫描
<context:component-scan base-package="包名"/>

<mvc:annotation-driven/>
<bean id='' class="" scope="" lazy-init=""    autowire="byName"  init-method="" destroy-method="">
@Component("")      @Scope("")     @Lazy("")  @Autowired  --@Qualifier("id") 
@Postconstruct    @PreDestroy

spring框架可以自动向处理器的处理方法传入request,session,和ModelMap对象


}





{
数据库SQL对于空字符串与null的情况返回的结果都是空的集合

向数据库传入空字符串,该字段结果为空,不为null;
	
JAVA空指针与空字符串的问题:
Integer.parseInt(null);//异常
Integer.parseInt("");//异常
System.out.println("".equals(null));  //false
//System.out.println(null.equals(""));  //编译错误  运行时空指针异常
System.out.println("xxx".equals(null));//false
System.out.println("xxx".equals(""));//false

		public User findByName(String name, String pwd)
			throws UserNotFoundException, PasswordNotCorrectEception {
		//判断空指针与空字符串的情况
		if(pwd==null||pwd.trim().isEmpty()) throw new PasswordNotCorrectEception("密码不能为空");
		User user=userDao.findByName(name);
		if(user==null) throw new UserNotFoundException("用户名错误");
		if(!user.getPassword().equals(pwd))throw new PasswordNotCorrectEception("密码错误");
		return user;
	}
	
	
	

}


反射{
1.Class c=Class_Name.calss;//使用泛型明确class类型(不会初始化)
2.Class c=Object.getClass();//同过实例对象获取class对象
3.Class c=Class.forName(String path);//通过class文件的路径获取class文件对象

Constructor Class.getDeclaredConstructors()
反射可以获取从父类继承,以及自己的全部公开的方法;
反射可以获取自己的全部方法(包括private,但是不能获取父类继承的方法);
未被重写的方法,实际上是去加载父类并调用父类的方法,需要考虑访问权限的问题.

protected Object Object.clone();
不重写该方法:只能在子类的成员方法中通过super关键字调用,(前提:在本类中)或者通过该子类对象的引用去调用



}


匿名内部类; 
 * 适合创建那种只使用一次的类，创建匿名内部类时会创建该类的实例，类定义立即消失，匿名内部类不能重复使用 
 * 必须继承一个父类或者实现一个接口，但是只能继承一个父类或者实现一个接口 
 * 还有2点注意 
 * 第一  匿名内部类不能是抽象类，因为抽象类不是实例化，而内部类要创建类的实例 
 * 第二  不能定义构造器，因为没有类名，但是可以定义实例初始化 
 *  
内部类可以另外继承或实现其他的类或接口
//(引用类型)强转编译不报错,运行时刻可能报错(子类引用指向父类对象运行抛出异常)
//子类可以拥有与父类同名的变量
//Fu f=new Zi();  等同于  Fu f=new Fu();  Zi z=new Zi();  f=z;(无需强转)
public class Zi extends Fu{
int i=3;
	public static void main(String[] args) {
		Fu f=new Zi();
		System.out.println(f.i);  //输出父类的变量i=1
		Zi z=new Zi();
		f=z;  //向上造型
	}
}
class Fu{
	int i=1;
	
}

{
	class Pet{
	 int x=0;}
	class Cat extends Pet{
	int x=0;  //子类可以拥有与父类同名的变量
Pet c= new Pet();
Cat p=  (Cat)c;}   //子类引用指向父类对象编译不报错,运行异常(强转)
}

//子类接口可以写出父类接口的同名抽象方法;而子接口的实现类只需实现一个方法即可
//子类接口的方法可以重载父类接口方法
interface Fu{
	void say();
}
interface Zi extends Fu{
	void say();
}
class x implements Zi{
	@Override
	public void say() {
	}
}

 
 Java中方法绑定有哪些形式？
    A.编译时刻绑定(static ,final,private)
    B.运行时刻绑定
    
    
  表达式"hello" instance of String返回的值是哪项？//true
  
	(List l=new ArrayList();
	l.add(1);
	l.add(2);
	for(Iterator it=l.iterator();it.hasNext();){ 
	//不使用泛型也能强转为Integer list加不加泛型迭代器取出来的都是Object对象
		Integer o=(Integer) it.next();
		System.out.println(o);  
	})
	
	编译时刻绑定的方法: 
	A．静态方法
    B. private方法
    C．final方法
	
关于try...catch...finally结构，描述正确的是哪项？  
		try{}finally{}   //正确
		try{}catch(Exception e){} //正确
		try{}//错误
AJAX{
AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。
AJAX 不是新的编程语言，而是一种使用现有标准的新方法。
AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。
AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。
}

{
在 PHP 中,有两种基本的输出方法:echo 和 print;
echo - 能够输出一个以上的字符串;
print - 只能输出一个字符串,并始终返回 1


Razor 是一种将基于服务器的代码添加到网页中的标记语法;
Razor 具有传统 ASP.NET 标记的功能,但更容易使用并且更容易学习;
Razor 是一种服务器端标记语法,与 ASP 和 PHP 很像;
Razor 支持 C# 和 Visual Basic 编程语言;所以选D
}

MyBatis{
 SqlSessionFactoryBuilder sfb=new SqlSessionFactoryBuilder();
 SqlSessionFactory sf=sfb.build(InputStream config);
 SqlSession ss=sf.openSession();//自带commit();rolllback（）；
 
 DefaultSqlSession(SqlSession接口的实现类)
 DefaultSqlSessionFactory(DefaultSqlSessionFactory接口的实现类)
 
 
 SqlSessionTemplate(实现了SqlSession接口,用户spring框架)
 SqlSessionFactoryBean
 MapperScannerConfigurer
 
 EmpDao dao=ss.getMapper(class<T>);

 @Param("id") String str
 映射文件中主要通过Param中的id来辨别参数
 如果是多个参数且参数的数据类型不一致，那么就不要写parameterType
 如果是多个数据类型相同的参数（数组，链表），paramterType="集合中元素的数据类型"，也可以不写
 
<insert  useGenarateKeys="true" keyProperty="">
 
需要手动关闭SqlSession对象,需要手动提交事务

映射文件
Mapper映射器:符合映射文件要求的接口(Dao类的接口)
SqlSession.getMapper(class<T>);

spring框架集成MyBatis(主要方式)
springjdbc: JdbcTemplate

6个包:spring框架2个包:spring-webmvc,spring-jdbc
	  jdbc连接池2个包:ojdbc,dbcp,
	  MyBatis两个包:mybatis,mybatis-spring

		SqlSessionFactoryBean
			dataSource
			mapperLocations
		MapperScannerConfigurer
			<property name="sqlSessionFactory" ref="sqlsf"/>
			<property name="basePackage" value="dao"/>
			[<property name="annotationClass" value="annotations.MapperAnnotation"/>]


Spring框架集成MyBatis(方式二)
SqlSessionTemplate


}


spring-jdbc{
	JdbcTemplate
	RowMapper
	
	
}


Ajax{
asynchronous javascript and xml
异步的js和xml
异步请求,接受响应时不会刷新页面

getResponseHeader();
getAllResponseHeaders();

json
用来代替xml的轻量级数据传输格式
跨平台(语法借鉴了js),封装数据
解析快

ajax对象属性:
onreadystatechange
readyState(0(请求未初始化),1(已连接服务器),2(请求发送成功),3(请求处理中,正在获取数据),4(获取了所有响应数据))
status(200(请求成功),302,400,404,500)
responseText
responseXML

缓存问题:发送get请求时,有的浏览器(IE)不会在向服务器发送相同的请求(同url),而是直接从缓存中提取数据.  (空内容的post方法会发送)不上传数据的post方式可以不用写请求头
post方式上传数据不设置消息头服务器无法读取数据


编码问题:get:   xhr.open('get',encodeURI(uri),true);
		post:

缓存问题:使用随机数添加URL后缀

<script type="text/javascript">



//1.获取ajax对象
function getXHR(){
var xhr;
//大部分浏览器都是支持的
if(XMLHttpRequest){
xhr=new XMLHttpRequest();
}
//老古董IE不支持
else{
	xhr=new ActiveXObject("MicroSoft.XMLHTTP");
}
return xhr;
}
</script>

//2.创建请求(get方式和post方式)
创建请求方法send(String method,String servletpath,boolean asynchronous)中
第三个参数为true:表示ajax对象发送请求和接受数据后不会销毁当前页面,用户可以操作当前页面
第三个参数为false:表示ajax对象发送请求和接受数据后不会销毁当前页面,但是当前页面被锁定,无法操作

1.get方式
xhr.send("get","url",true);  


//按照协议要求post请求必须带消息头,而ajax对象默认不会添加消息头
//post方法需要手动添加请求头
xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");



发送请求
xhr.send(null);//get方式请求最好加上null,如果什么都不写的话浏览器可能会不兼容

xhr.send("adminCode=亚索&pwd=1234");

网络通信


json
javascript object notation 声明
轻量级的数据交换格式(json借鉴了javascript的部分语法)
比xml空间占用小,读取速度快
数据交换:

java对象----------js对象





jQuery封装ajax对象:
url:
type:
data:
dataType:json字符串  经过JSON.parse(String json)来获取json对象数组
		 text  
		 html
		 xml  (一般用json代替)
		 script  js脚本
success  绑定请求成功的回调函数
		
		//obj表示服务器返回的数据(如果是json字符串,自动转换成json对象
		function (obj){
		}
		
error:  处理错误


$(obj).load("getPrice.do","flight="+flight);

//对象属性的先后顺序无所谓
$.ajax(xhrobj);  //$.ajax(xhrobj)方法
var xhrobj={"url":"  ",};

取特殊的key值比如关键字,数字   if,
list[0]["if"]
list[0]["88"]






//方式一:直接定义ajax对象
$.ajax({"url":"random.do","type":"get","dataType":"text","success":function(data){
		$("#show").val(data);
	}});
	
						method(post/get)
						//{"url":xxx}对象
$.ajax({"url":"check.do","type":"get","data":"adminCode=king"});


//方式二:
					//请求参数
$obj.load(String url[,data]);  //默认会将服务器放回的数据写在obj.innerHTML  input无效 需要使用回调函数 调用val();
$obj(url,data,function(x){});  //这里的x表示的是服务器返回的数据

$getJson(url,data,function(){});


$(selector).load(url,data,callback) 把远程数据加载到被选的元素中 
$.ajax(options) 把远程数据加载到 XMLHttpRequest 对象中 
$.get(url,data,callback,type) 使用 HTTP GET 来加载远程数据 
$.post(url,data,callback,type) 使用 HTTP POST 来加载远程数据 
$.getJSON(url,data,callback) 使用 HTTP GET 来加载远程 JSON 数据 
$.getScript(url,callback) 加载并执行远程的 JavaScript 文件 

(selector) jQuery 元素选择器语法

(url) 被加载的数据的 URL（地址）

(data) 发送到服务器的数据的键/值对象

(callback) 当数据被加载时，所执行的函数

(type) 被返回的数据的类型 (html,xml,json,jasonp,script,text)

(options) 完整 AJAX 请求的所有键/值对选项




Map显示的结构与entity类一样
{key:value}形式

list,数组都是  [{},{}]  ["","",""]

[{"age":5,"name":"Tom","price":4.5},{"age":6,"name":"Som","price":5.5}]

JSON是javascript的一部分
JSON是javascript的对象直接量语法,用于声明js对象
JSON字符串:符合JSON语法的字符串

//创建对象,创建数组

var obj={age:5,name:'TOM'}; //声明对象直接量

var ary=[1,"2",3,true];  //声明数组对象

var str='{"name":"TOM","age":6}';
var str='[{"name":"TOM","age":6},{"name":"SOM","age":7}]';

JSON字符串转换成json对象
//宽松版容易出BUG  直接调用eval(str);方法容易错误
JSON字符串转换成json对象   var str=xhr.responseText;
var jsonObj=JSON.parse(str);  //JSON.parse(String str)的底层是eval()函数

json可以存储对象,数组,字符串


//严谨写法
var obj=eval('('+str+')');  //加双括号



String 
public int compareTo(String anotherString) {
        int len1 = value.length;
        int len2 = anotherString.value.length;
        int lim = Math.min(len1, len2);
        char v1[] = value;
        char v2[] = anotherString.value;

        int k = 0;
        while (k < lim) {
            char c1 = v1[k];
            char c2 = v2[k];
            if (c1 != c2) {
                return c1 - c2;
            }
            k++;
        }
        return len1 - len2;
    }

// 自定义异常:可以继承自Exception或者RuntimeException


存储过程,存储函数,触发器

监听器,过滤器,拦截器



Object.writeValueAsString(Object o);//底层调用了反射机制获取对象属性(包括私有属性和从父类继承的属性)
//只会获取属性,不会获取方法


存储方式:
内存:
外存的文件:
外存的数据库:
外存的数据库:

内存:瞬态,分配对象(数据-对象),
外存:  数据库(管理文件的软件)(硬盘文件) DBMS提供了并发管理,适合多线程访问
写文件是一个线程,读取文件是多个线程
//文件只能单线程访问

数据结构:
数组;链表,哈希表,枚举


mysql  -u用户名 -p密码
mysql  -uroot  -p zzanywn

数据库来管理数据库(存用户名,密码,存储过程等等长久文件数据)
查询数据库  show database//

创建数据库对象: createt database db_name//
drop database db_name//


ENGINE=InnoDB DEFAULT CHARSET=utf8;
set names utf8  	--(mysql不能加'-'  utf8)
source file_path   --执行sql文件里面的命令

{
//apache,junit eclipse自带
	
spring-webmvc
spring-jdbc

mybatis
mybatis-spring

ojdbc || mysql
dbcp  2个包 或者c3p0

jsckson 3个包 或者 gson


<dependencies>
	<dependency>
  		<groupId>jstl</groupId>
  		<artifactId>jstl</artifactId>
  		<version>1.2</version>
  	</dependency>
	
  	<dependency>
  		<groupId>org.springframework</groupId>
  		<artifactId>spring-webmvc</artifactId>
  		<version>3.2.8.RELEASE</version>
  	</dependency>
  	
  	<dependency>
			<groupId>commons-dbcp</groupId>
			<artifactId>commons-dbcp</artifactId>
			<version>1.4</version>
		</dependency>
		
		<dependency>
  	<groupId>org.mybatis</groupId>
  	<artifactId>mybatis</artifactId>
  	<version>3.2.8</version>
  </dependency>
  <dependency>
  	<groupId>org.mybatis</groupId>
  	<artifactId>mybatis-spring</artifactId>
  	<version>1.2.3</version>
  </dependency>
  <dependency>
  	<groupId>org.springframework</groupId>
  	<artifactId>spring-jdbc</artifactId>
  	<version>3.2.8.RELEASE</version>
  </dependency>
  
  <dependency>
  <groupId>mysql</groupId>
  <artifactId>mysql-connector-java</artifactId>
  <version>5.1.6</version>
</dependency>
  
  <!-- jackson3个包 -->
  <dependency>
  		<groupId>com.fasterxml.jackson.core</groupId>
  		<artifactId>jackson-annotations</artifactId>
  		<version>2.2.3</version>
  	</dependency>
  	<dependency>
  		<groupId>com.fasterxml.jackson.core</groupId>
  		<artifactId>jackson-core</artifactId>
  		<version>2.2.3</version>
  	</dependency>
  	<dependency>
  		<groupId>com.fasterxml.jackson.core</groupId>
  		<artifactId>jackson-databind</artifactId>
  		<version>2.2.3</version>
  	</dependency>
  
  </dependencies>

  DigestUtil.md5Hex(String );  //生成MD5密码  (32位字符)
  UUID.randomUUID().toString();//自动生成唯一ID
  
  
    .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar
    bin,jre/bin
	
	
	//返回部分数据,用map封装部分字段
	JSON : list<Map<String,Object>>,List<Object>,Object
	//map取出的属性是无序的LinkedHashMap
}



{
	MyBatis框架对于可能查出多条记录但是返回值只有一个的情况会报异常
	新加入映射文件的(sql)语句必须
	泛化,把子类共有的属性和方法抽象到父类种,把该父类抽象
	
	$obj.on('click','selector',(function(){}));
	
	load是jQuery的异步方法,用来在加载网页
	异步加载网页
	
	window代表浏览器对象
	
	断点测试
	变量的值 变化  (Local内存值变化)
	
	实体类的属性名更应该和前端传进来的属性名相同,方便spring框架获取数据,封装对象
	实体类的属性还应该和数据库的字段名相同,方便查询,否则就要使用别名或者resultMap
	
	


数据结构(集合)
数组
链表()




算法(排序,查找)  
冒泡排序
二分法
快速查找


整数,小数
正数,负数

Integer.toBinaryString(int x);//转换成2进制
只有Integer和Long有解析数字成二进制的算法(方法)

所有底层的计算都是以二进制数的形式进行的,二进制数的补码
原码的
反码
补码


-n=~n+1
一个整数的负数等于该数取反+1


unicode 3.2  ucs char 类型 0~65535
超过的部分直接用int代替
String str=String.format("%010d",int x);


负数的>>操作(实际上是除以2^n):右移多少位就在最前面补多少位1  (小数的话向下取整数)
>>>的操作,无视正负数,最高位全部补0  负数>>>x会得到很大的正数
左移右移的优先级高于&高于|
<<,>>,>>> 高于 &  高于 ^ 高于 | 

float小数
指数,小数
Integer.toBinaryString(Float.floatToIntBits(float));

面向对象:
封装
继承
多态

js里声明的全局变量和方法其实都是window的属性和方法,与document无关

js
创建对象
设置属性
增删改查属性

js对象没有封装性,因为对象的属性可以随意增删
js不是面向对象的语言,只是基于对象;
js 对象的底层实际上是一个散列表,添加对象属性相当于直接put(key,value);
删除属性相当于remove(key);
访问对象属性相当于get(key);
//删除对象属性
delete obj.attr;
//添加对象属性  直接赋值
obj."key"="value";
//访问属性
obj.age
obj.say();//调用方法

<li class="disable">
	<a >
		<i class="fa fa-file-text-o cashNote" title="online" rel="tooltip-bottom"></i> [noteTitle]
		<button type="button" class="btn btn-default btn-xs btn_position btn_delete"><i class="fa fa-times"></i>
		</button>
		<button type="button" class="btn btn-default btn-xs btn_position_2 btn_replay"><i class="fa fa-reply"></i>
		</button>
	</a>
</li>';


//向jsp页面传值问题
1.数据绑定到request对象转发到jsp页面(返回值为String jsp_name)
2.数据绑定到map,封装到ModelAndView对象里发送过去(返回 new ModelAndView(String jsp_name,map))
3.数据绑定到ModelMap  ModelMap.addAttribute(String,Object);//底层还是利用request增加attribute
4.直接使用注解@ModelAttribute(String key)
5.直接使用Model对象(Model model) model.addAttribute(String,Object);

spring重定向:
1.
public String handle(){
	return  "redirect:xxxxxx";
}
2.
public ModelAndView handle(){
	return new ModelAndView(new RedirectView("xxxx"));

	
	
HTTP 1.0 短连接 ----->HTTP 1.1 长连接
HTTPS 安全机制
过滤器和拦截器都需要单独写入配置文件
拦截器也可以写入注解@Component  组件扫描(不是必须的) 但在注册bean时写成<ref bean=""/>必须写
也可以单独注册,<bean class="lk.note.interceptors.AccessInterceptor"/>不用写注解(不必要)

seesionId 在浏览器都存在cookie

//心跳监测
浏览器加一个脚本,定时发送请求服务器,使session一直保存.


静态执行
动态执行


反射API
动态创建对象
可以创建任何对象

如果没有父类了,Class.getSuperClass()方法返回null

//获取该方法的注解接口对象(返回null说明没有该注解)
Method.getAnnotationByType(Class<T> annotationClass);


反射的应用:
反射需要查找.class文件,耗时,容易出错,性能差
1.Eclipse的快捷键导出public属性和方法(包括父类的)
2.spring框架:bean对象的生成(singleton,调用构造方法(私有构造也行))
	动态加载类
	动态创建bean
	动态注入属性(包括私有属性注入)  (一般调用get,set方法)
	动态解析注解
3.myBatis 
实体类只会调用无参构造方法
获取设置属性优先调用get,set方法,没有才用反射
利用反射获取实体类的属性(没有get方法也行,有get方法直接调用get方法,没有get方法直接利用发射获取属性)
查询的时候,利用反射将查询结果注入实体对象中
创建实体类对象,将查询到的结果调用set方法注入属性



AOP面向切面编程(解耦,在不修改源代码的情况下给程序动态添加统一功能的技术,如日志记录,运行时间,事务管理)
基于性能测试
底层是动态代理(基于反射):动态创建类,动态调用方法
//创建代理对象,调用代理对象的方法




aop.@Before
us.findByName()
aop.@After
aop.@AfterReturning
//没有异常,先执行finally,在执行return


????
aop.@Before
us.findByName()
aop.@After
aop.@AfterThrowing
//有异常,先执行

try{
	@Before
	
	业务层方法
	
	@AfterReturning
	
	
}catch(Throwable t){
	@AfterThrowing
	
}finally{
	@After
}


around.业务方法执行前
aop.@Before
us.findByName()
around.业务方法执行后
业务方法执行后的结果为:User [id=ea09d9b1-ede7-4bd8-b43d-a546680df00b, name=yasuo, password=7908836f4219f9c41500829b164ddd6c, token=null, nick=null]
aop.@After
aop.@AfterThrowing




@Before

@Transactional//需要进行事务处理的
DML
update
delete
insert

@AfterReturning

@AfterThrowing

@After



@Component
@Aspect 
public class Demo1Aspect {

    /**
     * 环绕通知 方法:
     *  1. 必须有返回值值Object
     *  2. 必须有参数  ProceedingJoinPoint
     *  3. 必须抛出异常
     *  4. 需要在方法中调用  jp.proceed()
     *  5. 返回业务方法的返回值
     * @param jp
     * @return 
     * @throws Throwable
     */
    @Around("bean(userService)")
    public Object test5(ProceedingJoinPoint jp)
        throws Throwable{
        Object val = jp.proceed();
        System.out.println("业务结果:"+val);
        throw new UserNotFoundException(
                "就是不让登录");
    }

}
execution(User lk.note.service.UserService.findByName(String,String))
around.业务方法执行前
aop.@Before
us.findByName()
around.业务方法执行后
业务方法执行后的结果为:User [id=ea09d9b1-ede7-4bd8-b43d-a546680df00b, name=yasuo, password=7908836f4219f9c41500829b164ddd6c, token=null, nick=null]
aop.@After
aop.@AfterReturning
JsonResult(Object o)




拦截器可以测试整个请求-响应完成过程的时间
aop可以测试业务层(最耗时的操作)的完成过程时间

$Proxy

代理对象只能一个一个的调用方法,直接通过getMethods();方法获取的方法数组无法直接被proxy对象调用
NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not available [native method]


Object...args如果不传入参数,则args依然存在,只不过长度为0


代理类是公共的、最终的，而不是抽象的。 
未指定代理类的非限定名称。但是，以字符串 "$Proxy" 开头的类名空间应该为代理类保留。 
代理类扩展 java.lang.reflect.Proxy。 
代理类会按同一顺序准确地实现其创建时指定的接口。 
如果代理类实现了非公共接口，那么它将在与该接口相同的包中定义。否则，代理类的包也是未指定的。注意，包密封将不阻止代理类在运行时在特定包中的成功定义，也不会阻止相同类加载器和带有特定签名的包所定义的类。 
由于代理类将实现所有在其创建时指定的接口，所以对其 Class 对象调用 getInterfaces 将返回一个包含相同接口列表的数组（按其创建时指定的顺序），对其 Class 对象调用 getMethods 将返回一个包括这些接口中所有方法的 Method 对象的数组，并且调用 getMethod 将会在代理接口中找到期望的一些方法。 
如果 Proxy.isProxyClass 方法传递代理类（由 Proxy.getProxyClass 返回的类，或由 Proxy.newProxyInstance 返回的对象的类），则该方法返回 true，否则返回 false。 
代理类的 java.security.ProtectionDomain 与由引导类加载器（如 java.lang.Object）加载的系统类相同，原因是代理类的代码由受信任的系统代码生成。此保护域通常被授予 java.security.AllPermission。 
每个代理类都有一个可以带一个参数（接口 InvocationHandler 的实现）的公共构造方法，用于设置代理实例的调用处理程序。并非必须使用反射 API 才能访问公共构造方法，通过调用 Proxy.newInstance 方法（将调用 Proxy.getProxyClass 的操作和调用带有调用处理程序的构造方法结合在一起）也可以创建代理实例。 


violation 违反
moudle 模件

spring模式,框架,技术

声明式事务  ---->  aop   ----->  动态代理  ----->  反射

(事件冒泡)
事务传播
一个业务处理方法的事务传播到另一个业务处理方法的事务
事务的整合

数据库并发操作(读锁/写锁)
隔离级别
serializable（串行化）：可避免 脏读、不可重复读、虚读情况的发生。
repeatable read（可重复读）：可避免 脏读、不可重复读， 不可避免 虚读。mysql采用可重复读。
read committed（读已提交）：可避免 脏读，不可避免 不可重复读、虚读。oracle采用读已提交。
read uncommitted（读未提交）：不可避免 脏读、不可重复读、虚读。


1.串行化(序列化) 最高级别的隔离,效率最低,最安全(每个线程(事务)之间按顺序执行,一个事务结束后另外一个事物才能执行)
2.可以重复读取()
3.读取提交后的数据(修改状态的数据读不到)//默认(并发和安全的平衡选择) 可以同时开启读和写的事务,但只能读取写入操作中提交的数据,可能在一次读的事务中,
4.可以读取修改中(未提交的数据)的数据(脏读)


1.脏读
2.不可复读(update操作,删除)
3.幻读(删除插入操作)


http 1.1
http 2.0
http文件如何下载
html,css,js,media,text,xml,image,json

ByteArrayOutputStream 存在内存的临时性的字节输出流

initator

<image title="鼠标悬浮时显示文字" alt="图片丢失时显示的描述信息" src="直接写请求,发送get请求获取图片"/>


显示图片：直接设置
@RequestMapping(value="",produces="image/png" )

下载图片
@ResponseBody
	//@ResponseBody会自动处理控制返回值,如果是javabean对象,自动把该对象转换成json字符串
	//如果是byte[]数组,则将该数组直接封装进响应的消息body
	//这里的produces="image/png" 相当于 resp.setContentType("image/png");
	@RequestMapping(value="/downImage.do",produces="application/octet-stream")
	public byte[] downloadImg(HttpServletResponse resp) throws IOException{
	//这里必须写名响应头  filename表示下载的文件名字
	resp.setHeader("Content-Disposition", "attachment;filename=\"img.png\"");
		return createImg1();
	}
	
response.setContentType("test/html");
//识别不了的类型,全部按文件下载,文件名为域名

excel文件下载
需要导包poi
<dependency>
  <groupId>org.apache.poi</groupId>
  <artifactId>poi-ooxml</artifactId>
  <version>3.13</version>
</dependency>


工作库,工作表,行和列
//创建Excel文件
	private byte[] createExcel()throws IOException{
//		us.
		//把数据库的数据存入Excel文件
		
		//1.创建工作库(Excel文件)
		HSSFWorkbook workbook=new HSSFWorkbook();
		
		//2.创建工作表
		HSSFSheet sheet=workbook.createSheet("demo");
		
		//3.创建数据行  
		HSSFRow row=sheet.createRow(0);
		
		//4.创建数据列(格子)
		
		HSSFCell cell=row.createCell(0);
		cell.setCellValue("HelloWorld");
		
		//把Excel文件保存为byte数组
		ByteArrayOutputStream out=new 
				ByteArrayOutputStream();
		workbook.write(out);
		
		return out.toByteArray();
	}
	
//接收上传的文件
	@ResponseBody
	@RequestMapping("/upload.do")
//spring利用MutipartFile接收上传的文件 文件中的一切数据 对象的引用名字必须和表单提交文件的name属性值保持一致
public JsonResult upload(MultipartFile userFile1,MultipartFile userFile2) throws IOException{
		System.out.println("/upload.do");
		
		String file1=userFile1.getOriginalFilename();//获取完整的文件名(包括文件类型信息)
		String file2=userFile2.getOriginalFilename();
		System.out.println(file1);
		System.out.println(file2);
	//保存文件到服务器本地
		//1.userFile1.transferTo(目标文件) 可以处理大文件
		//2.userFile1.getBytes();  获取文件的全部数据,将文件全部读取到内存中,适合读取小文件
//		byte[]bs=userFile1.getBytes();
//		bs=userFile1.getBytes();
//		PrintWriter pw=new PrintWriter(new BufferedOutputStream(new FileOutputStream(""),"utf-8"));
		
		//3.userFile1.getInputStream();  获取上传文件的流,适合处理大文件(transferTo的底层就是)
		
		File dir=new File("d:/file");
		dir.mkdir();
		/*userFile1.transferTo(new File(dir,file1));
		userFile2.transferTo(new File(dir,file2));*/
		
		
		BufferedInputStream is=new BufferedInputStream(userFile1.getInputStream());
		BufferedOutputStream bs=new BufferedOutputStream(new FileOutputStream("d:/file"+file1));
		int x=-1;
		while((x=is.read())!=-1){
			
		}
		
		
		
		System.out.println("文件保存完毕");
		return new JsonResult(true);
	}

	
	The current request is not a multipart request
	
	
ea09d9b1-ede7-4bd8-b43d-a546680df00b


List<Map<String, Object>>findNotes(@Param("user")String arg0,@Param("notebookId")String arg1,@Param("statusId")String arg2);

<select id="findNotes" resultType='map'>
select cn_note_id noteId ,cn_note_title as noteTitle from cn_note
<!-- 去除多于的and -->
<trim  suffixOverrides="and" >  <!--prefixOverrides="and"  -->
<where>
<!--这里的test属性值表示的是@Param("name"),#{与前面的name相同} -->
<if test="user!=null">cn_user_id=#{user} and </if>
<if test="notebookId!=null">cn_notebook_id=#{notebookId} and </if>
<if test="statusId!=null">cn_note_status_id=#{statusId} and </if>
</where>
</trim>
order by cn_note_last_modify_time desc
</select>


Mybatis
替换表名,字段名,关键字,用${}绑定

多表关联查询

${} sql语句的拼接 (必须小心使用,有可能造成sql注入)  可以用来传入表名,字段名
#{} PreparedStatement传入参数
所有基本数据类型都用他的包装类

insert into table () values(),(),();//一次插入多条记录


useGenarateKeys="true"


js使用<input type="file" />表单空间直接上传文件
function ajaxUpload(){
	var file1 = $('#file1')[0].files[0];
	var file2 = $('#file2')[0].files[0];
	//创建内存中的表单对象
	var form = new FormData();
	//添加向服务器传输的数据
	form.append('userFile1', file1);
	form.append('userFile2', file2);
	
	$.ajax({
		url:'user/upload.do',
		data: form,
		type: 'POST',
		dataType: 'json',
		contentType: false,
		processData: false, 
		success: function(obj){
			if(obj.state==1){
				$('#result').html("成功!"); 
			}
		}
	});
}

{
	
	// @ResponseBody会自动处理控制返回值,如果是javabean对象,自动把该对象转换成json字符串
	// 如果是byte[]数组,则将该数组直接封装进响应的消息body
	// 这里的produces="image/png" 相当于 response.setContentType("image/png");
	@ResponseBody
	@RequestMapping(value = "/image.do", produces = "image/png")
	
	传入图片:
	1.直接用response.getWriter();输出图片
	
	
	
}



{
反射.动态代理
JDK动态代理只能对接口做动态代理
CGlib是spring框架中更加强大的动态代理Api
1.jdk动态代理技术的实现依赖与InvocationHandler接口和Proxy实体类
2.动态代理需要一个实现InvocationHandler接口的实体类,这个类的实例化需要传入代理对象
3.动态代理对象不要获取全部方法的数组,如此调用会出错
4.Object o=new Instance();
o.getMethod(String methodName,Object...args) 这样调用只能获取引用o中的方法
o.getDeclaredMethod(String methodName,Object...args); 这样调用可以获取引用o指向的实例对象的方法

o.getMethods();可以获取实例对象和引用中的全部公开方法
//实例对象的方法
public java.lang.String proxyTest.StuDaoImp.getName(proxyTest.Stu)
public int proxyTest.StuDaoImp.getAge(proxyTest.Stu)
public void proxyTest.StuDaoImp.say()

//引用中的全部方法
public final void java.lang.Object.wait() throws java.lang.InterruptedException
public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException
public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException
public boolean java.lang.Object.equals(java.lang.Object)
public java.lang.String java.lang.Object.toString()
public native int java.lang.Object.hashCode()
public final native java.lang.Class java.lang.Object.getClass()
public final native void java.lang.Object.notify()
public final native void java.lang.Object.notifyAll()





o.getDeclaredMethods();只能获取实例对象中的全部方法(包括私有方法)
public java.lang.String proxyTest.StuDaoImp.getName(proxyTest.Stu)
public int proxyTest.StuDaoImp.getAge(proxyTest.Stu)
public void proxyTest.StuDaoImp.say()
private void proxyTest.StuDaoImp.pri()



//代理类的方法不同与被代理对象的方法,不能混调用

for(Method x:ms){
			//用实体类生成的Method数组依次调用没有问题
			//用代理类生成的Method数组会报异常
			x.invoke(ud);//没有问题
//			System.out.println(m);

//			代理类生成的数组也报异常debug
//			x.invoke(proxy);//异常  object is not an instance of declaring class
		}
//代理类的方法全部final修饰
0 : public final void com.sun.proxy.$Proxy0.add()
1 : public final boolean com.sun.proxy.$Proxy0.equals(java.lang.Object)
2 : public final java.lang.String com.sun.proxy.$Proxy0.toString()
3 : public final int com.sun.proxy.$Proxy0.hashCode()
4 : public final void com.sun.proxy.$Proxy0.update()
5 : public final void com.sun.proxy.$Proxy0.find()
6 : public final void com.sun.proxy.$Proxy0.delete()


//实体类自己的方法
0 : public void cn.itcast_06.UserDaoImpl.add()
1 : public void cn.itcast_06.UserDaoImpl.update()
2 : public void cn.itcast_06.UserDaoImpl.find()
3 : public void cn.itcast_06.UserDaoImpl.delete()

}
思想    模式
关联映射
集合创建出来的时候直接调用构造方法避免空指针异常

<计算机编程艺术>
1. tomcat:web.xml
DispatcherServlet  |StrutsPrepareAndExecuteFilter
CharacterEncodingFilter
自定义HTMLFilter(只有过滤器能过滤匹配路径以外的其他资源请求)
2. Spring: spring-*.xml



{

ApplicationContext  ClassPathXmlApplicationContext

StrutsPrepareAndExecuteFilter(Struts2主控制器)
						<!--一级目录要有/xxx,二级目录不需要/,否则报错,找不到路径  -->
<package name="demo" namespace="/demo" extends="struts-default">
        <!--由于使用Spring来管理Action，因此需要通过Spring
            容器来创建Action，因此class属性指定的是组件的ID。-->
        <action name="hello" class="helloAction">
            <result name="success">
                /hello.jsp
            </result>
        </action>
</package>


spring容器由DispatcherServlet来启动
整合struts后,主控制器由StrutsPrepareAndExecuteFilter代替,所以需要另外配置一个监听器(ContextLoaderListener)来启动spring框架
<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
  </listener>
  <context-param>
  	<param-name>contextConfigLocation</param-name>
  	<param-name>classpath:spring-*.xml</param-name>
  </context-param>

 <action name="hello" class="写class文件路径名,就是Struts管理,写bean的ID,表示有spring管理">
 <result name="ok"> /WEB-INF/xxx.jsp</result></action>
 result标签默认是转发的
 这两者都行,但spring有更强大的依赖注入和Aop事务管理
 用spring管理子处理器,必须要用原型@Scope("prototype")
Spring框架整合Struts2
Struts2主控制器StrutsPrepareAndExecuteFilter
struts2为了保证线程安全,每一个用户请求都需要单独写一个处理类,处理请求时创建对个(XxxAction)对象.每个线程独享一个子处理器的对象.
spring多请求共享一个处理器对象,spring利用参数注入解决线程安全问题
每个线程共享一个处理器对象,但传递的参数不同.
1. 如何接受用户的提交数据
	利用bean属性(特指访问对象属性的get,set方法)
	获取的数据利用set方法设置Action类中的属性值

getUv: null
setUv UserValue [name=null, password=null, age=null, address=null]
getUv: UserValue [name=null, password=null, age=null, address=qweds]
getUv: UserValue [name=null, password=null, age=32, address=qweds]
getUv: UserValue [name=yasuo, password=null, age=32, address=qweds]
execute: UserValue [name=yasuo, password=q2weds, age=32, address=qweds]
	
getUv: null
UserValue()
setUv UserValue [name=null, password=null, age=null, address=null]
setAddress
//UserValue [name=null, password=null, age=null, address=null]
getUv: UserValue [name=null, password=null, age=null, address=2额外的所]
setAge
//UserValue [name=null, password=null, age=null, address=2额外的所]
getUv: UserValue [name=null, password=null, age=23, address=2额外的所]
setName
//UserValue [name=null, password=null, age=23, address=2额外的所]
getUv: UserValue [name=yasuo, password=null, age=23, address=2额外的所]
setPassword
//UserValue [name=yasuo, password=null, age=23, address=2额外的所]
execute: UserValue [name=yasuo, password=1234abvc, age=23, address=2额外的所]


getUv: null
UserValue()
setUv UserValue [name=null, password=null, age=null, address=null]
setAddress
//UserValue [name=null, password=null, age=null, address=wedsc]
getUv: UserValue [name=null, password=null, age=null, address=wedsc]
setAge
//UserValue [name=null, password=null, age=23, address=wedsc]
getUv: UserValue [name=null, password=null, age=23, address=wedsc]
setName
//UserValue [name=wahaha, password=null, age=23, address=wedsc]
getUv: UserValue [name=wahaha, password=null, age=23, address=wedsc]
setPassword
//UserValue [name=wahaha, password=1234, age=23, address=wedsc]
execute: UserValue [name=wahaha, password=1234, age=23, address=wedsc]


Session储存数据



参数传递,直接使用Map<String,Object>map传入响应的request,session,application
StrutsPrepareAndExecuteFilter
C.ActionSupport

重写setXxxx方法
I.SessionAware
I.RequestAware
I.ApplicationAware


}

HTTP下载
<result-type name="stream" class="org.apache.struts2.dispatcher.StreamResult"/>


//展示图片
//下载图片
//下载Excel

struts原生不支持json,需要导入json的插件  struts2-json-plugin
该插件不需要再导入解析实体类为JSON字符串的包
<jsp:forward page = "newworld.jsp" ></jsp:forward>
jsp:forward可以实现页面跳转的效果 作用是转发 所以浏览器地址不会发生变化

<c:forEach items="${}" var="">


WEB Server
Apache(HTTP Server)   Nginx(HTTP Server)  Java Web 服务器(Servlet容器)Tomcat
}

jstl
//c.tld文件
JSP可以使用Struts标签,直接导入即可
<%@taglib uri="/struts-tags" prefix="s"%>
ValueStack
struts共享数据的机制,利用ValueStack可以在Struts组件之间共享数据
struts组件:
1. StrutsPrepareAndExecuteFilter
2. Action
3. result
4. 视图JSP
5. valueStack(控制器的属性存储位置)
配置文件 struts.xml

<s:property value="name" />


Element : rtexprvalue
Defines if the nesting attribute can have scriptlet expressions as a value, i.e the value of the 
 attribute may be dynamically calculated at request time, as opposed to a static value 
 determined at translation time. If not present then the default is "false", i.e the attribute has a 
 static value

Data Type : string
Enumerated Values : 
	- true
	- false
	- yes
	- no
	
OGNL(对象图导航语言)
在任何组件中
使用OGNL读取ValueStack数据的时候是按照从顶到下顺序查找,找到第一个匹配的就返回该值
尽量不要使用重复的属性名
Struts底层接管了EL和JSTL,将EL数据读取到ValueStack.EL的读取结果与ONGL一样

如果需要读取ValueStack的context区域,必须使用ValueStack  (#key)


JAVA EE是基础
spring是JAVA EE基础之上的简化框架(spring可以独立使用,但一般在JAVA EE环境中运行.JUNIT测试时是直接调用spring的)

WEB 开发需要java EE,多了两个jar包(jsp-api.jar和servlet-api.jar,定义了一些规范接口,具体需要服务器软件如Tomcat实现)

Struts(架子)
Mybatis
Spring
Hibernate(冬眠):以面向对象的方式操作数据库,不使用面向过程的sql
1. 不用写sql,但需要重新写hql(hql是基于sql的)
2. 会生成不理想的SQL,影响数据库性能
3. 特殊操作,无法实现
解决ORM问题(Object relation Mapping)对象关系映射问题
底层还是JDBC (SQL)

ClassPathXmlApplicationContext ac=new ClassPathXmlApplicationContext("spring.xml","spring-struts.xml");

servlet组件如何设置文件下载(2步):
1. response.setContentType("application/octet-stream");
2. response.setHeader("Content-Disposition","attachment;filename=\"img.png\"");

处理文件上传,需要导入两个包
commons-fileupload-1.2.2.jar
另一个是commons-io-2.0.1.jar
需要限定上传文件的类型和大小: 设置上传文件的拦截器

<action name="upload" class="">
    <interceptor-ref name="fileUpload">  
    <param name="allowedTypes">  
image/bmp,image/png,image/gif,image/pjpeg,image/jpg   
                </param>

  <param name="maximumSize">2048</param>//限定图片大小不能超过2k  
         </interceptor-ref>      
		 
         <interceptor-ref name="defaultStack"></interceptor-ref>  
         <result name="error">/error.jsp</result>  
         <result name="input">/upload.jsp</result>  
</action>  



//xhr.setRequestHeader("contentType","application/");
spring-mvc中;直接设置@RequestMapping(value="url" produce="application/octet-stream");
在方法体中设置响应头:response.setHeader("Content-Disposition","attachment;filename=\"img.png\"");




struts2中,设置action标签
<action name="" class="">
<result name="ok" type="stream" >
			//	这里的值img代表action类中的inputStream img 属性
	<param name="inputName">img</param>
	<param name="contentDisposition">attachment;filename="img.png"</param>
</result>


</action>

servlet组件文件上传


//没有该属性,必有该setXxx()方法
spring-mvc需要配置上传文件解析器MultipartResolver
org.springframework.web.multipart.commons.CommonsMultipartResolver
<property name="maxUploadSize" value="10000000"/>
    <property name="defaultEncoding" value="utf-8"/>
<form method="post" action="url" enctype="multipart/form-data">
MultipartFile

var file1 = $('#file1')[0].files[0];
	var file2 = $('#file2')[0].files[0];
	//创建内存中的表单对象
	var form = new FormData();
	//添加向服务器传输的数据
	form.append('userFile1', file1);
	form.append('userFile2', file2);

	
	Struts2提供了异常处理,但是基于网页的标准错误页面提示,不太友好,需要自己设置异常处理
	
	
	{
		配置连接池
		//MyBatis映射文件扫描可以写成/mappers/*.xml来表示该文件夹下全部映射文件
		MyBatis:
		整合spring需要配置的bean:
		1. sqlSessionFactory(dataSource,mapperLocations)
		2. MapperScannerConfigurer(sqlSessionFactory,basePackage)
		//基于spring AOP的事务管理
		3. DataSourceTransactionManager(dataSource)//基于连接池管理事务 
		//设置注解驱动事务管理
		4. <tx:annotation-driven transaction-manager="dataSourceTransactionManager" />
		
		//Hibernate映射文件只能写成list,一个一个写
		Hibernate
		1. LocalSessionFactoryBean(dataSource,mappingLocations,hibernateProperties[hibernate.dialect,hibernate.show_sql,hibernate.format_sql])
		2. org.springframework.orm.hibernate3.HibernateTemplate(sessionFactory)
		////基于sessionFactory管理事务
		3. org.springframework.orm.hibernate3.HibernateTransactionManager(sessionFactory)
		//设置注解驱动事务管理
		4. <tx:annotation-driven transaction-manager="dataSourceTransactionManager" />
		
		独立使用:
		1. Configuration builder=new Configuration();
		2. builder.configure(String path);//读取配置文件
		3. SessionFactory ssf=builder.buildSessionFactory();//创建SessionFactory
		4. Session ss=ssf.openSession();
		//Hibernate 默认不提交事务,需要手动开启Transaction对象
		//Transaction ts=ss.beginTransaction();
		// ts.commit();
	
	Configuration
	SessionFactory
	Session
	Transaction
	Query
	
		@Test
	public void findAll(){
		String hql="from User";
		List<User> list=ss.createQuery(hql).list();
		for(User u:list){
			System.out.println(u);
		}
	}
	//模糊查询
	@Test
	public void search(){
		String hql="from User where name like :name";
		Query query=ss.createQuery(hql);
		query.setString("name", "%皮%");
		List<User>list=query.list();
		for(User u:list){
			System.out.println(u);
		}
	}
	
	@Test
	public void search(){
//		String hql="from User where name like :name";
		String hql="from User where name like ?";
		Query query=ss.createQuery(hql);
	// query.setString("name", "%皮%");
		query.setString(0, "%皮%");
		List<User>list=query.list();
		for(User u:list){
			System.out.println(u);
		}
	}
		@Test
	public void findByName(){
//			String hql="from User where name= :name";
//			Query q=ss.createQuery(hql);
//			q.setString("name", "皮皮揭");
//			List<User> u=q.list();
//			System.out.println(u);
			
			String hql="from User where name=?";
			User u=(User) ss.get("lk.note.entity.User", "e2e46dfa-5dd3-4659-bc5d-079abcca4d0f");
			System.out.println(u);
	}
	//违反主键约束,后面更新的记录会替换掉原来id的记录
	79069dae-cca1-4d66-bc74-069bba9dcb28 | pipijuan     | 2b72fedca21db9bfdf86b52debf9e5e5 | NULL          | 皮皮娟       |
	e2e46dfa-5dd3-4659-bc5d-079abcca4d0f | pipijuan     | 2b72fedca21db9bfdf86b52debf9e5e5 | NULL          | 皮皮娟       |	
		
		回归性测试
		以前测试过在进行测试
	}
	
	Struts2拦截器(实现com.opensymphony.xwork2.interceptor.Interceptor接口,或者继承
	public abstract class com.opensymphony.xwork2.interceptor.AbstractInterceptor implements com.opensymphony.xwork2.interceptor.Interceptor)
	拦截器栈(多个拦截器一同工作,拦截器的容器)
	//系统拦截器有很多个
	拦截器:
	1. 拦截异常
	2. 记录地区/语言 zh_CN
	3. FileUpload
	4. Parameter 参数检查(把参数放入ValueStack)  Interceptor检查参数
	5. Validation
	
	
	Struts配置文件的书写有些元素必须按顺序书写,否则会报错.
	
	CAP(Consistency,Availability,Partitiontolerance)
	
				//把查询到的部分结果装入map容器,property as key,不写key则默认为0,1,2...
	String hql="select new map(bookId as id, name as name ) from Notebook where userId=?";
		
		@SuppressWarnings("unchecked")
		List<Map<String, Object>>list=hibernateTemplate.find(hql, userId);
		return list;
	
	
	Hibernate: 
    insert 
    into
        cn_user
        (cn_user_name, cn_user_nick, cn_user_token, cn_user_password, cn_user_id) 
    values
        (?, ?, ?, ?, ?)
Hibernate: 
    update
        cn_user 
    set
        cn_user_name=?,
        cn_user_nick=?,
        cn_user_token=?,
        cn_user_password=? 
    where
        cn_user_id=?
		
		
Hibernate延迟加载对象 Session.load(Object.class,Object primaryKey),实际上使用的是代理对象(只有id属性的空壳)，如果找不到就会抛异常（ObjectNotFoundExcepption）只有需要访问该对象的其他属性是才会访问数据库
Session.get(Object.class,Object primaryKey)使用的是实体对象,如果找不到该对象返回null

无论是load还是get，返回的对象都是持久状态	  (持久状态下不会修改主键)
//IdentityGenerator(Hibernate提供的主键自增)  <generator class="identity" />


标准js创建ajax请求:
1. 创建ajax对象 var xhr= new XMLHttpRequest();
2. 设置请求参数: xhr.open(url,method,true);
3. 设置回调函数: xhr.onreadystatechange=function(data){}
3. xhr.send(null);


$.ajax({url:"",data:"",dataType:"",success:function(){},error:function(){}})
$(selector).load(url,data,callback) 把远程数据加载到被选的元素中 
$.ajax(options) 把远程数据加载到 XMLHttpRequest 对象中 
$.get(url,data,callback,type) 使用 HTTP GET 来加载远程数据 
$.post(url,data,callback,type) 使用 HTTP POST 来加载远程数据 
$.getJSON(url,data,callback) 使用 HTTP GET 来加载远程 JSON 数据 
$.getScript(url,callback) 加载并执行远程的 JavaScript 文件 



Session是接口，hibernate框架提供的实现类是SessionImpl
Hibernate中Session的
Session是轻量级的，可以随意的创建和销毁
Session不是线程安全的


exclusion 排除，拦截器排除？
spring-mvc：


文件上传需要导入2个包,commons-fileupload 和commons-io

//上传文件解析器的配置
<bean id="multipartResolver"
    class="org.springframework.web.multipart.commons.CommonsMultipartResolver">

    <!-- one of the properties available; the maximum file size in bytes -->
    <property name="maxUploadSize" value="10000000"/><!-- 十万字节(一次上传的所有文件不超过10M) -->
    <property name="defaultEncoding" value="utf-8"/>
	</bean>

延迟加载:
OpenSessionInViewFilter

Hibernate更新的弊端:
需要传入一个完整的对象实体,全部属性都根据该对象更新.而如果只提交了该对象的部分修改属性,其他属性却被修改为null了
解决方案:
1. 在提交的表单中声明哪些属性是不需要更新的
<s:hidden name="OGNL"/> (如果不需要修改的字段很多,需要重复写,很麻烦)
2. 直接在映射文件ORM.xml中关闭更新<property name="" column="" update="false"/> (永久关闭该属性的更新了,其他业务要更新却无法操作)
3. 将orm映射文件的class类设置为动态更新属性(只在属性发生改变才更新,但只对持久状态下的对象有效)
因为表单提交的数据而创建的实体对象是临时状态,需要先用get(<T>,Serializable id)获取持久状态的对象,在用Spring的BeanUtils工具类
将临时状态对象的属性复制给持久状态对象完成更新
<class name="cn.tedu.note.entity.Note" table="cn_note" dynamic-update="true">
BeanUtils.copyProperties(Object source,Object target);



response.setContentType("text/html");
MIME类型以类型/子类型（type/subtype）的形式表示。

其中type表示一下几种典型文件格式的一种：

Text、Audio、Video、Image、Application、Mutipart、Message

Subtype则用来描述具体所用的数据格式。

Application/msword

微软的Word文件

Application/octet-stream  

一种通用的二进制文件格式(包括图片)

Application/zip

Zip压缩文件

Application/pdf

Pdf文件


CAP定理Consistency）， 可用性（Availability）， 分区容错性（Partition tolerance)
Check and 

ASM

缓存一致性问题:(多线程范文同一数据)
1> 内存上锁(锁总线)
2> 缓存一致性协议:Intel 的MESI协议

js的str.replace("a","0");//把str字符串中的第一个"a"替换为"0"
js的str.replace(/a/g,"0");//把str字符串中的全部"a"替换为"0"


接收页面参数值有3种方式
	使用request
	使用@RequestParam注解  eg:  public Object handleRequest(@RequestParam("password") String pwd)
	//不写注解默认从request中直接获取变量名的数据,如果没有则取得null,可作类型转换,如果是基本数据类型取不到值得抛出异常
	//写了@RequestParam("name")如果娶不到值直接抛异常
	使用实体对象(自动把接受的数据封装成对象)

向页面传出数据有3种方式
	使用ModelAndView对象 return new ModelAndView(String url,Map map);
	使用ModelMap对象    方法传入参数ModelMap,ModelMap.addAttribute(String key,Object value);
	使用@ModelAttribute注解 使用该注解,则每次匹配请求后执行service方法前都会先调用@ModelAttribute的方法
	在Controller方法参数上直接声明HttpSession即可使用
重定向有2种方式
使用RedirectView  return new ModelAndView(new RedirectView(String path));
使用redirect:  return "redirect: url";

转发的2个方法:
1> forward(request,response); //全部委托转发页面处理请求,此方法执行之后的request,response操作将不再生效
2> include(request,response);//保留本页面继续处理的权利

Mybatis中Dao对应的方法不可重载,如需要可变的参数可用动态Sql语句


<!--springboot热编译  有的地方可能不生效(比如新增方法)-->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<!--<scope>provided</scope>-->
			<!--optional我没弄明白，都说必须为true，但我测试true，false，不加都可以-->
			<optional>true</optional>
		</dependency>

org.springframework.data.mapping.PropertyReferenceException: No property findAll found for type Demo!
这个异常是因为同一个实体类上面有了@NodeEntity注解

MongoRepository的insert方法返回的结果就是你存入的对象
模板提供的方法中,
insert,save是有主键唯一校验的,重复主键插入报错


SimpleDateFormat sdf=new SimpleDateFormat("yyyyMMddHHmmssSSS");//日期格式化,精确到毫秒数,可以逆推回日期Date
int objectId.getTimestamp();    //1526704917
long (new Date).getTime();		//1526704917000

match(xx:Demo) return xx  order by id(xx) desc limit 10   //返回的结果必须有@QueryResult注解申明映射


<video controls="" autoplay="" name="media">
	<source src="https://dl.stream.qqmusic.qq.com/M800001Js78a40BZU6.mp3?vkey=8E7ADDD88E1F0C66BFE6FAE263F9D3A8C0B126A0510BDC35B33FC787AEB4CED65DAA803339FB361A26C7AB7343412E6F870FBD5A8F3C3E49&amp;guid=5150825362&amp;fromtag=1" type="audio/mpeg">
</video> 

方法为：Page<?> findAll(Pageable pageable); 该方法中的参数是一个借口，我们需要构造一个子对象，
即：PageRequest对象,这个对象中有两个属性，第一个是页码，第二个是页面大小。注意：页码在mongodb中是从0开始的。
 public Page<Person> queryAllByPage(int page,int rows) throws Exception {
        PageRequest pageRequest = new PageRequest(page-1,rows);
        return personRepository.findAll(pageRequest);
    }
 仓库中添加的方法：
         public Person findByName(String name); 
        它会自动根据name查询。
        service中的方法

根据实体类中的属性进行模糊查询：
        当需要根据实体类中的属性进行模糊查询时，我们也需要在PersonRepository仓库中定义方法，模糊查询定义方法名的规则为：find + By + 属性名（首字母大写） + Like，如：根据姓名进行模糊查询Person
        仓库中添加的方法：
        public List<Person> findByNameLike(String name);

  @Query(value="{'name':?0}",fields="{'name':1}")
    public Page<Person> findByNameLike(String name,Pageable pageable);
	 其中value是查询的条件，？0这个是占位符，对应着方法中参数中的第一个参数，如果对应的是第二个参数则为？1。fields是我们指定的返回字段，其中id是自动返回的，不用我们指定，bson中{'name':1}的1代表true，也就是代表返回的意思。

	 
	 @Test
    public void testIndex() throws Exception {
        MvcResult mvcResult = mockMvc
                .perform(// 1
                        MockMvcRequestBuilders.get("/index") // 2
                        .param("name","admin") // 3
                )
                .andReturn();// 4

        int status = mvcResult.getResponse().getStatus(); // 5
        String responseString = mvcResult.getResponse().getContentAsString(); // 6

        Assert.assertEquals("请求错误", 200, status); // 7
        Assert.assertEquals("返回结果不一致", "this is index pageadmin", responseString); // 8
    }


	 
	 
存入demo集合中100000条数据耗时:3 s
存入demoCopy集合中100000条数据耗时:2 s
demo数据迁移耗时:13s
demoCopy数据迁移耗时:8s
relation关系数据迁移耗时:26s      整体耗时1.3min  查询关系还需要优化    有索引
count(1)
99197

type                   mongo    neo4j
demo    	num   
           100000      3 s       16s,12s,12s,9s
demoCopy   num   
           100000      2 s       10s,11s,10s,10s
relation   num   				 12s
           100000      
		   
		   demo2018052113040174999101
		   
mongo  十万数据  2~3s

UNWIND {rows} as row CREATE (n:`Demo`) 
SET n=row.props
 RETURN row.nodeRef as ref, ID(n) as id, {type} as type 
 with params {type=node, rows=[{nodeRef=-1, props={mongoId=[1526915654, 7944188, 20700, 15853784], no=0, name=yasuo}}]}

//应用内发送http请求
RestTemplate req = new RestTemplate();
        ResponseEntity<Integer> resp=req.exchange("http://localhost:"+port+"/myPort", HttpMethod.GET,null,Integer.class);
        return resp.getBody();
		
ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();//这个静态方法可以直接获取当前处理请求		


db.getCollection('BaseRelation').find({}).size()
var num=

var obj=db.BaseRelation.aggregate([{$group:{_id:"$end",count:{$sum:1}}},{$match:{count:{$gte:2}}}],{allowDiskUse:true})
obj.constructor
obj.itcount()
obj.toArray(


db.eval('more2moreResult()');
var dbQuery=db.BaseRelation.find({end:{$nin:excludeArr}}).sort({start:1}).skip(0).limit(100);


db.system.js.insert({_id:'one2moreResult',value:function(from,to){
    var excludeArr=db.eval('more2moreResult()');
    var dbQuery=db.BaseRelation.find({end:{$nin:excludeArr}}).sort({start:1}).skip(from-1).limit(to-from+1);
    return dbQuery.toArray();
    }})
    
    
    
    
    
db.system.js.update({_id:'more2moreResult'},{_id:'more2moreResult',value:function(){
    var aggregate=db.BaseRelation.aggregate([{$group:{_id:"$end",count:{$sum:1}}},{$match:{count:{$gte:2}}}],{allowDiskUse:true});
    var excludes=aggregate.toArray();
    var resultArr=[];
    for(var i=0;i<excludes.length;i++){
        resultArr.push(excludes[i]._id);
        };
        return resultArr;
    
    return aggregate;
    }});
    
   var obj= db.eval('more2moreResult(1,100)')


db.BaseRelation.aggregate([{$group:{_id:"$end",count:{$sum:1}}},{$match:{count:{$gte:2}}},{$out:'aggregate'}])//allowDiskUse:true,

db.more2moreResult()
    
    db.system.js.insert()



num

.size()
var obj=db.BaseRelation.mapReduce(function(){emit(this.end,1);},function(k,v){return Array.sum(v);})



db.BaseRelation.mapReduce( 
   function() { emit(this.end,1); }, 
   function(key, values) {return Array.sum(values)}, 
      {  
//          // query :{value:{$gte:2}},
         // finalize:function(key,result,arr){return {$match:{}}   },
//           match:{value:{$gte:2}},
          
         out:"multiEnd" 
      }
)



var val=function(){
    var aggregate=db.BaseRelation.aggregate([{$group:{_id:"$end",count:{$sum:1}}},{$match:{count:{$gte:2}}}],{allowDiskUse:true});
    var excludes=aggregate.toArray();
    var resultArr=[];
    for(var i=0;i<excludes.length;i++){
        resultArr.push(excludes[i]._id);
        }
    }
    val();
    
    
    
var arr=db.getCollection('multiEnd').find({value:{$gte:2}},{_id:1})
// typeof arr
arr.constructor

var arr=db.BaseRelation.aggregate([{$group:{_id:"$end",count:{$sum:1}}},{$match:{count:{$gte:2}}}],{allowDiskUse:true}) //
db.BaseRelation.find({end:{$nin:db.getCollection('multiEnd').find({value:{$gte:2}},{_id:1}).toArray()}}).size()
    
    
    
    
